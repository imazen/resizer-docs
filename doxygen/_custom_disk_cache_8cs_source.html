<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ImageResizer: C:/Users/Administrator/Documents/resizer/Plugins/DiskCache/CustomDiskCache.cs Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="resizer-icon-64.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ImageResizer
   &#160;<span id="projectnumber">3.2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">C:/Users/Administrator/Documents/resizer/Plugins/DiskCache/CustomDiskCache.cs</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 ï»¿<span class="comment">/* Copyright (c) 2011 Nathanael Jones. See license.txt for your rights. */</span>
<a name="l00002"></a>00002 <span class="keyword">using</span> System;
<a name="l00003"></a>00003 <span class="keyword">using</span> System.Collections.Generic;
<a name="l00004"></a>00004 <span class="keyword">using</span> System.Text;
<a name="l00005"></a>00005 <span class="keyword">using</span> ImageResizer.Caching;
<a name="l00006"></a>00006 <span class="keyword">using</span> System.IO;
<a name="l00007"></a>00007 <span class="keyword">using</span> ImageResizer.Configuration.Logging;
<a name="l00008"></a>00008 <span class="keyword">using</span> System.Diagnostics;
<a name="l00009"></a>00009 <span class="keyword">using</span> System.Threading;
<a name="l00010"></a>00010 <span class="keyword">using</span> ImageResizer.Plugins.DiskCache.Async;
<a name="l00011"></a>00011 <span class="keyword">using</span> System.Globalization;
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="keyword">namespace </span>ImageResizer.Plugins.DiskCache {
<a name="l00014"></a>00014     <span class="keyword">public</span> delegate <span class="keywordtype">void</span> CacheResultHandler(CustomDiskCache sender, CacheResult r);
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">    /// &lt;summary&gt;</span>
<a name="l00017"></a>00017 <span class="comment">    /// Handles access to a disk-based file cache. Handles locking and versioning. </span>
<a name="l00018"></a>00018 <span class="comment">    /// Supports subfolders for scalability.</span>
<a name="l00019"></a>00019 <span class="comment">    /// &lt;/summary&gt;</span>
<a name="l00020"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html">00020</a> <span class="comment"></span>    <span class="keyword">public</span> <span class="keyword">class </span><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html" title="Handles access to a disk-based file cache. Handles locking and versioning. Supports subfolders for sc...">CustomDiskCache</a> {
<a name="l00021"></a>00021         <span class="keyword">protected</span> <span class="keywordtype">string</span> physicalCachePath;
<a name="l00022"></a>00022 
<a name="l00023"></a>00023         <span class="keyword">public</span> <span class="keywordtype">string</span> PhysicalCachePath {
<a name="l00024"></a>00024             <span class="keyword">get</span> { <span class="keywordflow">return</span> physicalCachePath; }
<a name="l00025"></a>00025         }
<a name="l00026"></a>00026         <span class="keyword">protected</span> <span class="keywordtype">int</span> subfolders;
<a name="l00027"></a>00027         <span class="keyword">protected</span> <span class="keywordtype">bool</span> hashModifiedDate;
<a name="l00028"></a>00028         <span class="keyword">protected</span> <a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger_provider.html">ILoggerProvider</a> lp;
<a name="l00029"></a>00029         <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html" title="Handles access to a disk-based file cache. Handles locking and versioning. Supports subfolders for sc...">CustomDiskCache</a>(<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger_provider.html">ILoggerProvider</a> lp, <span class="keywordtype">string</span> physicalCachePath, <span class="keywordtype">int</span> subfolders, <span class="keywordtype">bool</span> hashModifiedDate):<span class="keyword">this</span>(lp,physicalCachePath,subfolders,hashModifiedDate, 1024*1024*10) {
<a name="l00030"></a>00030 
<a name="l00031"></a>00031         }
<a name="l00032"></a>00032         <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html" title="Handles access to a disk-based file cache. Handles locking and versioning. Supports subfolders for sc...">CustomDiskCache</a>(<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger_provider.html">ILoggerProvider</a> lp, <span class="keywordtype">string</span> physicalCachePath, <span class="keywordtype">int</span> subfolders, <span class="keywordtype">bool</span> hashModifiedDate, <span class="keywordtype">long</span> asyncMaxQueuedBytes) {
<a name="l00033"></a>00033             this.lp = lp;
<a name="l00034"></a>00034             this.physicalCachePath = physicalCachePath;
<a name="l00035"></a>00035             this.subfolders = subfolders;
<a name="l00036"></a>00036             this.hashModifiedDate = hashModifiedDate;
<a name="l00037"></a>00037             this.CurrentWrites.MaxQueueBytes = asyncMaxQueuedBytes;
<a name="l00038"></a>00038         }<span class="comment"></span>
<a name="l00039"></a>00039 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00040"></a>00040 <span class="comment">        /// Fired immediately before GetCachedFile return the result value. </span>
<a name="l00041"></a>00041 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00042"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a3c6eebab73d41d608b5638aa0d992806">00042</a> <span class="comment"></span>        <span class="keyword">public</span> <span class="keyword">event</span> CacheResultHandler <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a3c6eebab73d41d608b5638aa0d992806" title="Fired immediately before GetCachedFile return the result value.">CacheResultReturned</a>; 
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 
<a name="l00045"></a>00045         <span class="keyword">protected</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread-safe.">LockProvider</a> locks = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread-safe.">LockProvider</a>();<span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00047"></a>00047 <span class="comment">        /// Provides string-based locking for file write access.</span>
<a name="l00048"></a>00048 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00049"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#ad6e28a6622b78c69d52b492ac1cd84dc">00049</a> <span class="comment"></span>        <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread-safe.">LockProvider</a> Locks {
<a name="l00050"></a>00050             <span class="keyword">get</span> { <span class="keywordflow">return</span> locks; }
<a name="l00051"></a>00051         }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053         <span class="keyword">protected</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread-safe.">LockProvider</a> queueLocks = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread-safe.">LockProvider</a>();<span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00055"></a>00055 <span class="comment">        /// Provides string-based locking for image resizing (not writing, just processing). Prevents duplication of efforts in asynchronous mode, where &#39;Locks&#39; is not being used.</span>
<a name="l00056"></a>00056 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00057"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a43828a7d93f9850dd2497a48013cbcd6">00057</a> <span class="comment"></span>        <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread-safe.">LockProvider</a> QueueLocks {
<a name="l00058"></a>00058             <span class="keyword">get</span> { <span class="keywordflow">return</span> queueLocks; }
<a name="l00059"></a>00059         }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061         <span class="keyword">private</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html">AsyncWriteCollection</a> _currentWrites = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html">AsyncWriteCollection</a>();<span class="comment"></span>
<a name="l00062"></a>00062 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00063"></a>00063 <span class="comment">        /// Contains all the queued and in-progress writes to the cache. </span>
<a name="l00064"></a>00064 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00065"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a561a334189a8a0169f3e204bdb825502">00065</a> <span class="comment"></span>        <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html">AsyncWriteCollection</a> CurrentWrites {
<a name="l00066"></a>00066             <span class="keyword">get</span> { <span class="keywordflow">return</span> _currentWrites; }
<a name="l00067"></a>00067         }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         <span class="keyword">private</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_index.html" title="Provides thread-safe access to the index of the disk cache.">CacheIndex</a> index = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_index.html" title="Provides thread-safe access to the index of the disk cache.">CacheIndex</a>();<span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00073"></a>00073 <span class="comment">        /// Provides an in-memory index of the cache.</span>
<a name="l00074"></a>00074 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00075"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#abe47e92a8f0bee35ac7b08a02777b4ef">00075</a> <span class="comment"></span>        <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_index.html" title="Provides thread-safe access to the index of the disk cache.">CacheIndex</a> Index {
<a name="l00076"></a>00076             <span class="keyword">get</span> { <span class="keywordflow">return</span> index; }
<a name="l00077"></a>00077         }
<a name="l00078"></a>00078         
<a name="l00079"></a>00079         
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00082"></a>00082 <span class="comment">        /// If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries to cache the data and return the path.</span>
<a name="l00083"></a>00083 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00084"></a>00084 <span class="comment">        /// &lt;param name=&quot;keyBasis&quot;&gt;The basis for the key. Should not include the modified date, that is handled inside the function.&lt;/param&gt;</span>
<a name="l00085"></a>00085 <span class="comment">        /// &lt;param name=&quot;extension&quot;&gt;The extension to use for the cached file.&lt;/param&gt;</span>
<a name="l00086"></a>00086 <span class="comment">        /// &lt;param name=&quot;writeCallback&quot;&gt;A method that accepts a Stream argument and writes the data to it.&lt;/param&gt;</span>
<a name="l00087"></a>00087 <span class="comment">        /// &lt;param name=&quot;sourceModifiedUtc&quot;&gt;The modified date of the source file. Should be DateTime.MinValue if not available&lt;/param&gt;</span>
<a name="l00088"></a>00088 <span class="comment">        /// &lt;param name=&quot;timeoutMs&quot;&gt;&lt;/param&gt;</span>
<a name="l00089"></a>00089 <span class="comment">        /// &lt;returns&gt;&lt;/returns&gt;</span>
<a name="l00090"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794">00090</a> <span class="comment"></span>        <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794" title="If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries t...">GetCachedFile</a>(<span class="keywordtype">string</span> keyBasis, <span class="keywordtype">string</span> extension, ResizeImageDelegate writeCallback, DateTime sourceModifiedUtc, <span class="keywordtype">int</span> timeoutMs) {
<a name="l00091"></a>00091             <span class="keywordflow">return</span> GetCachedFile(keyBasis, extension, writeCallback, sourceModifiedUtc, timeoutMs, <span class="keyword">false</span>);
<a name="l00092"></a>00092         }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment"></span>
<a name="l00095"></a>00095 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00096"></a>00096 <span class="comment">        /// May return either a physical file name or a MemoryStream with the data. </span>
<a name="l00097"></a>00097 <span class="comment">        /// Faster than GetCachedFile, as writes are (usually) asynchronous. If the write queue is full, the write is forced to be synchronous again.</span>
<a name="l00098"></a>00098 <span class="comment">        /// Identical to GetCachedFile() when asynchronous=false</span>
<a name="l00099"></a>00099 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00100"></a>00100 <span class="comment">        /// &lt;param name=&quot;keyBasis&quot;&gt;&lt;/param&gt;</span>
<a name="l00101"></a>00101 <span class="comment">        /// &lt;param name=&quot;extension&quot;&gt;&lt;/param&gt;</span>
<a name="l00102"></a>00102 <span class="comment">        /// &lt;param name=&quot;writeCallback&quot;&gt;&lt;/param&gt;</span>
<a name="l00103"></a>00103 <span class="comment">        /// &lt;param name=&quot;sourceModifiedUtc&quot;&gt;&lt;/param&gt;</span>
<a name="l00104"></a>00104 <span class="comment">        /// &lt;param name=&quot;timeoutMs&quot;&gt;&lt;/param&gt;</span>
<a name="l00105"></a>00105 <span class="comment">        /// &lt;returns&gt;&lt;/returns&gt;</span>
<a name="l00106"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a43cbe092ec6180f6f30fff0c7dd4d270">00106</a> <span class="comment"></span>        <span class="keyword">public</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a43cbe092ec6180f6f30fff0c7dd4d270" title="May return either a physical file name or a MemoryStream with the data. Faster than GetCachedFile...">GetCachedFile</a>(<span class="keywordtype">string</span> keyBasis, <span class="keywordtype">string</span> extension, ResizeImageDelegate writeCallback, DateTime sourceModifiedUtc, <span class="keywordtype">int</span> timeoutMs, <span class="keywordtype">bool</span> asynchronous) {
<a name="l00107"></a>00107             Stopwatch sw = null;
<a name="l00108"></a>00108             <span class="keywordflow">if</span> (lp.Logger != null) { sw = <span class="keyword">new</span> Stopwatch(); sw.Start(); }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111             <span class="keywordtype">bool</span> hasModifiedDate = !sourceModifiedUtc.Equals(DateTime.MinValue);
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 
<a name="l00114"></a>00114             <span class="comment">//Hash the modified date if needed.</span>
<a name="l00115"></a>00115             <span class="keywordflow">if</span> (hashModifiedDate &amp;&amp; hasModifiedDate)
<a name="l00116"></a>00116                 keyBasis += <span class="stringliteral">&quot;|&quot;</span> + sourceModifiedUtc.Ticks.ToString(NumberFormatInfo.InvariantInfo);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118             <span class="comment">//Relative to the cache directory. Not relative to the app or domain root</span>
<a name="l00119"></a>00119             <span class="keywordtype">string</span> relativePath = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_url_hasher.html">UrlHasher</a>().<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_url_hasher.html#adc687dc9cee3f675ce65cfd2be49657e" title="Builds a key for the cached version, using the hashcode of the normalized URL. if subfolders &gt; 1...">hash</a>(keyBasis, subfolders, <span class="stringliteral">&quot;/&quot;</span>) + <span class="charliteral">&#39;.&#39;</span> + extension;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121             <span class="comment">//Physical path</span>
<a name="l00122"></a>00122             <span class="keywordtype">string</span> physicalPath = PhysicalCachePath.TrimEnd(<span class="charliteral">&#39;\\&#39;</span>, <span class="charliteral">&#39;/&#39;</span>) + System.IO.Path.DirectorySeparatorChar +
<a name="l00123"></a>00123                     relativePath.Replace(<span class="charliteral">&#39;/&#39;</span>, System.IO.Path.DirectorySeparatorChar);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 
<a name="l00126"></a>00126             <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a> result = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a>(<a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Hit, physicalPath, relativePath);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128             <span class="keywordtype">bool</span> asyncFailed = <span class="keyword">false</span>;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130              <span class="comment">//On the first check, verify the file exists using System.IO directly (the last &#39;true&#39; parameter).</span>
<a name="l00131"></a>00131             <span class="keywordflow">if</span> (!asynchronous) {
<a name="l00132"></a>00132                 <span class="comment">//On the first check, verify the file exists using System.IO directly (the last &#39;true&#39; parameter)</span>
<a name="l00133"></a>00133                 <span class="comment">//May throw an IOException if the file cannot be opened, and is locked by an external processes for longer than timeoutMs. </span>
<a name="l00134"></a>00134                 <span class="comment">//This method may take longer than timeoutMs under absolute worst conditions. </span>
<a name="l00135"></a>00135                 <span class="keywordflow">if</span> (!TryWriteFile(result, physicalPath, relativePath, writeCallback, sourceModifiedUtc, timeoutMs, <span class="keyword">true</span>)) {
<a name="l00136"></a>00136                     <span class="comment">//On failure</span>
<a name="l00137"></a>00137                     result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#acd995c6ea0a45350729d72bb88af1f31" title="The result of the cache check.">Result</a> = <a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Failed;
<a name="l00138"></a>00138                 }
<a name="l00139"></a>00139             }<span class="keywordflow">else</span> <span class="keywordflow">if</span> ((!hasModifiedDate || hashModifiedDate) ? !Index.existsCertain(relativePath, physicalPath) : !Index.modifiedDateMatchesCertainExists(sourceModifiedUtc, relativePath, physicalPath)) {
<a name="l00140"></a>00140                 
<a name="l00141"></a>00141                 <span class="comment">//Looks like a miss. Let&#39;s enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention, as it doesn&#39;t include the </span>
<a name="l00142"></a>00142                 <span class="comment">//This prevents two identical requests from duplicating efforts. Different requests don&#39;t lock.</span>
<a name="l00143"></a>00143 
<a name="l00144"></a>00144                 <span class="comment">//Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage.</span>
<a name="l00145"></a>00145                 <span class="keywordflow">if</span> (!QueueLocks.TryExecute(relativePath.ToUpperInvariant(), timeoutMs,
<a name="l00146"></a>00146                     delegate() {
<a name="l00147"></a>00147 
<a name="l00148"></a>00148                         <span class="comment">//Now, if the item we seek is in the queue, we have a memcached hit. If not, we should check the index. It&#39;s possible the item has been written to disk already.</span>
<a name="l00149"></a>00149                         <span class="comment">//If both are a miss, we should see if there is enough room in the write queue. If not, switch to in-thread writing. </span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151                         <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a> t = CurrentWrites.Get(relativePath, sourceModifiedUtc);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153                         <span class="keywordflow">if</span> (t != null) result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#a46dd75c9f55a1061b9c4f80fa354d2bb" title="Provides a read-only stream to the data. Usually a MemoryStream instance, but you should dispose it o...">Data</a> = t.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#a5955b11b1055470663e3ad3c04451e56" title="Wraps the data in a readonly MemoryStream so it can be accessed on another thread.">GetReadonlyStream</a>();
<a name="l00154"></a>00154 
<a name="l00155"></a>00155                         <span class="comment">//On the second check, use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).</span>
<a name="l00156"></a>00156                         <span class="keywordflow">if</span> (t == null &amp;&amp;
<a name="l00157"></a>00157                             ((!hasModifiedDate || hashModifiedDate) ? !Index.exists(relativePath, physicalPath) : !Index.modifiedDateMatches(sourceModifiedUtc, relativePath, physicalPath))) {
<a name="l00158"></a>00158 
<a name="l00159"></a>00159                                 result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#acd995c6ea0a45350729d72bb88af1f31" title="The result of the cache check.">Result</a> = <a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Miss;
<a name="l00160"></a>00160                             <span class="comment">//Still a miss, we even rechecked the filesystem. Write to memory.</span>
<a name="l00161"></a>00161                             MemoryStream ms = <span class="keyword">new</span> MemoryStream(4096);  <span class="comment">//4K initial capacity is minimal, but this array will get copied around alot, better to underestimate.</span>
<a name="l00162"></a>00162                             <span class="comment">//Read, resize, process, and encode the image. Lots of exceptions thrown here.</span>
<a name="l00163"></a>00163                             writeCallback(ms);
<a name="l00164"></a>00164                             ms.Position = 0;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166                             <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a> w = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a>(CurrentWrites,ms, physicalPath, relativePath, sourceModifiedUtc);
<a name="l00167"></a>00167                             <span class="keywordflow">if</span> (CurrentWrites.Queue(w, delegate(<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a> job) {
<a name="l00168"></a>00168                                 <span class="keywordflow">try</span> {
<a name="l00169"></a>00169                                     Stopwatch swio = <span class="keyword">new</span> Stopwatch();
<a name="l00170"></a>00170                                     
<a name="l00171"></a>00171                                     swio.Start();
<a name="l00172"></a>00172                                     <span class="comment">//TODO: perhaps a different timeout?</span>
<a name="l00173"></a>00173                                     <span class="keywordflow">if</span> (!TryWriteFile(null, job.PhysicalPath, job.RelativePath, delegate(Stream s) { ((MemoryStream)job.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#a5955b11b1055470663e3ad3c04451e56" title="Wraps the data in a readonly MemoryStream so it can be accessed on another thread.">GetReadonlyStream</a>()).WriteTo(s); }, job.ModifiedDateUtc, timeoutMs, <span class="keyword">true</span>)) {
<a name="l00174"></a>00174                                         swio.Stop();
<a name="l00175"></a>00175                                         <span class="comment">//We failed to lock the file.</span>
<a name="l00176"></a>00176                                         <span class="keywordflow">if</span> (lp.Logger != null) 
<a name="l00177"></a>00177                                             lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a2a3c0e13cb37d522b1dd8f4f1fdb669d" title="Writes the diagnostic message at the Warn level.">Warn</a>(<span class="stringliteral">&quot;Failed to flush async write, timeout exceeded after {1}ms - {0}&quot;</span>,  result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#ab6b009d31bcd4f00308a4f82c16f57ae" title="The path relative to the cache.">RelativePath</a>, swio.ElapsedMilliseconds);
<a name="l00178"></a>00178                                         
<a name="l00179"></a>00179                                     } <span class="keywordflow">else</span> {
<a name="l00180"></a>00180                                         swio.Stop();
<a name="l00181"></a>00181                                         <span class="keywordflow">if</span> (lp.Logger != null)
<a name="l00182"></a>00182                                             lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a5125ea275ed8c2dda55c6f8e9f082b97" title="Writes the diagnostic message at the Trace level.">Trace</a>(<span class="stringliteral">&quot;{0}ms: Async write started {1}ms after enqueue for {2}&quot;</span>, swio.ElapsedMilliseconds.ToString().PadLeft(4), DateTime.UtcNow.Subtract(w.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#add6b89ca915007089f9bebbfdfb82dee" title="Returns the UTC time this AsyncWrite object was created.">JobCreatedAt</a>).Subtract(swio.Elapsed).TotalMilliseconds, result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#ab6b009d31bcd4f00308a4f82c16f57ae" title="The path relative to the cache.">RelativePath</a>);
<a name="l00183"></a>00183                                     }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185                                 } <span class="keywordflow">catch</span> (Exception ex) {
<a name="l00186"></a>00186                                     <span class="keywordflow">if</span> (lp.Logger != null) {
<a name="l00187"></a>00187                                         lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a4502d6eee54e1e6a4fd7ae51e3c915b1" title="Writes the diagnostic message at the Error level.">Error</a>(<span class="stringliteral">&quot;Failed to flush async write, {0} {1}\n{2}&quot;</span>,ex.ToString(), result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#ab6b009d31bcd4f00308a4f82c16f57ae" title="The path relative to the cache.">RelativePath</a>,ex.StackTrace);
<a name="l00188"></a>00188                                     }
<a name="l00189"></a>00189                                 } <span class="keywordflow">finally</span> {
<a name="l00190"></a>00190                                     CurrentWrites.Remove(job); <span class="comment">//Remove from the queue, it&#39;s done or failed. </span>
<a name="l00191"></a>00191                                 }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193                             })) {
<a name="l00194"></a>00194                                 <span class="comment">//We queued it! Send back a read-only memory stream</span>
<a name="l00195"></a>00195                                 result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#a46dd75c9f55a1061b9c4f80fa354d2bb" title="Provides a read-only stream to the data. Usually a MemoryStream instance, but you should dispose it o...">Data</a> = w.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#a5955b11b1055470663e3ad3c04451e56" title="Wraps the data in a readonly MemoryStream so it can be accessed on another thread.">GetReadonlyStream</a>();
<a name="l00196"></a>00196                             } <span class="keywordflow">else</span> {
<a name="l00197"></a>00197                                 asyncFailed = <span class="keyword">false</span>;
<a name="l00198"></a>00198                                 <span class="comment">//We failed to queue it - either the ThreadPool was exhausted or we exceeded the MB limit for the write queue.</span>
<a name="l00199"></a>00199                                 <span class="comment">//Write the MemoryStream to disk using the normal method.</span>
<a name="l00200"></a>00200                                 <span class="comment">//This is nested inside a queuelock because if we failed here, the next one will also. Better to force it to wait until the file is written to disk.</span>
<a name="l00201"></a>00201                                 <span class="keywordflow">if</span> (!TryWriteFile(result, physicalPath, relativePath, delegate(Stream s) { ms.WriteTo(s); }, sourceModifiedUtc, timeoutMs, <span class="keyword">false</span>)) {
<a name="l00202"></a>00202                                     <span class="keywordflow">if</span> (lp.Logger != null)
<a name="l00203"></a>00203                                         lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a2a3c0e13cb37d522b1dd8f4f1fdb669d" title="Writes the diagnostic message at the Warn level.">Warn</a>(<span class="stringliteral">&quot;Failed to queue async write, also failed to lock for sync writing: {0}&quot;</span>, result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#ab6b009d31bcd4f00308a4f82c16f57ae" title="The path relative to the cache.">RelativePath</a>);
<a name="l00204"></a>00204                                         
<a name="l00205"></a>00205                                 }
<a name="l00206"></a>00206                             }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208                         }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210                     })) {
<a name="l00211"></a>00211                     <span class="comment">//On failure</span>
<a name="l00212"></a>00212                     result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#acd995c6ea0a45350729d72bb88af1f31" title="The result of the cache check.">Result</a> = <a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Failed;
<a name="l00213"></a>00213                 }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215             }
<a name="l00216"></a>00216             <span class="keywordflow">if</span> (lp.Logger != null) {
<a name="l00217"></a>00217                 sw.Stop();
<a name="l00218"></a>00218                 lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a5125ea275ed8c2dda55c6f8e9f082b97" title="Writes the diagnostic message at the Trace level.">Trace</a>(<span class="stringliteral">&quot;{0}ms: {3}{1} for {2}, Key: {4}&quot;</span>, sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4), result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#acd995c6ea0a45350729d72bb88af1f31" title="The result of the cache check.">Result</a>.ToString(), result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#ab6b009d31bcd4f00308a4f82c16f57ae" title="The path relative to the cache.">RelativePath</a>, asynchronous ? (asyncFailed ? <span class="stringliteral">&quot;Fallback to sync  &quot;</span> : <span class="stringliteral">&quot;Async &quot;</span>) : <span class="stringliteral">&quot;&quot;</span>, keyBasis);
<a name="l00219"></a>00219             }
<a name="l00220"></a>00220             <span class="comment">//Fire event</span>
<a name="l00221"></a>00221             <span class="keywordflow">if</span> (CacheResultReturned != null) CacheResultReturned(<span class="keyword">this</span>, result);
<a name="l00222"></a>00222             <span class="keywordflow">return</span> result;
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment"></span>
<a name="l00226"></a>00226 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00227"></a>00227 <span class="comment">        /// Returns true if either (a) the file was written, or (b) the file already existed with a matching modified date.</span>
<a name="l00228"></a>00228 <span class="comment">        /// Returns false if the in-process lock failed. Throws an exception if any kind of file or processing exception occurs.</span>
<a name="l00229"></a>00229 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00230"></a>00230 <span class="comment">        /// &lt;param name=&quot;result&quot;&gt;&lt;/param&gt;</span>
<a name="l00231"></a>00231 <span class="comment">        /// &lt;param name=&quot;physicalPath&quot;&gt;&lt;/param&gt;</span>
<a name="l00232"></a>00232 <span class="comment">        /// &lt;param name=&quot;relativePath&quot;&gt;&lt;/param&gt;</span>
<a name="l00233"></a>00233 <span class="comment">        /// &lt;param name=&quot;writeCallback&quot;&gt;&lt;/param&gt;</span>
<a name="l00234"></a>00234 <span class="comment">        /// &lt;param name=&quot;sourceModifiedUtc&quot;&gt;&lt;/param&gt;</span>
<a name="l00235"></a>00235 <span class="comment">        /// &lt;param name=&quot;timeoutMs&quot;&gt;&lt;/param&gt;</span>
<a name="l00236"></a>00236 <span class="comment">        /// &lt;param name=&quot;recheckFS&quot;&gt;&lt;/param&gt;</span>
<a name="l00237"></a>00237 <span class="comment">        /// &lt;returns&gt;&lt;/returns&gt;</span>
<a name="l00238"></a>00238 <span class="comment"></span>        <span class="keyword">private</span> <span class="keywordtype">bool</span> TryWriteFile(<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a> result, <span class="keywordtype">string</span> physicalPath, <span class="keywordtype">string</span> relativePath, ResizeImageDelegate writeCallback, DateTime sourceModifiedUtc, <span class="keywordtype">int</span> timeoutMs, <span class="keywordtype">bool</span> recheckFS) {
<a name="l00239"></a>00239 
<a name="l00240"></a>00240             <span class="keywordtype">bool</span> hasModifiedDate = !sourceModifiedUtc.Equals(DateTime.MinValue);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242             <span class="keywordtype">bool</span> miss = <span class="keyword">true</span>;
<a name="l00243"></a>00243             <span class="keywordflow">if</span> (recheckFS) {
<a name="l00244"></a>00244                 miss = (!hasModifiedDate || hashModifiedDate) ? !Index.existsCertain(relativePath, physicalPath) : !Index.modifiedDateMatchesCertainExists(sourceModifiedUtc, relativePath, physicalPath);
<a name="l00245"></a>00245                 <span class="keywordflow">if</span> (!miss) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00246"></a>00246             }
<a name="l00247"></a>00247                
<a name="l00248"></a>00248 
<a name="l00249"></a>00249             <span class="comment">//Lock execution using relativePath as the sync basis. Ignore casing differences. This locking is process-local, but we also have code to handle file locking.</span>
<a name="l00250"></a>00250             <span class="keywordflow">return</span> Locks.TryExecute(relativePath.ToUpperInvariant(), timeoutMs,
<a name="l00251"></a>00251                 delegate() {
<a name="l00252"></a>00252 
<a name="l00253"></a>00253                     <span class="comment">//On the second check, use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).</span>
<a name="l00254"></a>00254                     <span class="keywordflow">if</span> ((!hasModifiedDate || hashModifiedDate) ? !Index.exists(relativePath, physicalPath) : !Index.modifiedDateMatches(sourceModifiedUtc, relativePath, physicalPath)) {
<a name="l00255"></a>00255 
<a name="l00256"></a>00256                         <span class="comment">//Create subdirectory if needed.</span>
<a name="l00257"></a>00257                         <span class="keywordflow">if</span> (!Directory.Exists(Path.GetDirectoryName(physicalPath))) {
<a name="l00258"></a>00258                             Directory.CreateDirectory(Path.GetDirectoryName(physicalPath));
<a name="l00259"></a>00259                             <span class="keywordflow">if</span> (lp.Logger != null) lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a098c60a5a927ededf2700652f79a42a3" title="Writes the diagnostic message at the Debug level.">Debug</a>(<span class="stringliteral">&quot;Creating missing parent directory {0}&quot;</span>, Path.GetDirectoryName(physicalPath));
<a name="l00260"></a>00260                         }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262                         <span class="comment">//Open stream </span>
<a name="l00263"></a>00263                         <span class="comment">//Catch IOException, and if it is a file lock,</span>
<a name="l00264"></a>00264                         <span class="comment">// - (and hashmodified is true), then it&#39;s another process writing to the file, and we can serve the file afterwards</span>
<a name="l00265"></a>00265                         <span class="comment">// - (and hashmodified is false), then it could either be an IIS read lock or another process writing to the file. Correct behavior is to kill the request here, as we can&#39;t guarantee accurate image data.</span>
<a name="l00266"></a>00266                         <span class="comment">// I.e, hashmodified=true is the only supported setting for multi-process environments.</span>
<a name="l00267"></a>00267                         <span class="comment">//TODO: Catch UnathorizedAccessException and log issue about file permissions.</span>
<a name="l00268"></a>00268                         <span class="comment">//... If we can wait for a read handle for a specified timeout.</span>
<a name="l00269"></a>00269                         
<a name="l00270"></a>00270                         <span class="keywordflow">try</span> {
<a name="l00271"></a>00271                             
<a name="l00272"></a>00272                             System.IO.FileStream fs = <span class="keyword">new</span> FileStream(physicalPath, FileMode.Create, FileAccess.Write, FileShare.None);
<a name="l00273"></a>00273                             <span class="keywordtype">bool</span> finished = <span class="keyword">false</span>;
<a name="l00274"></a>00274                             <span class="keywordflow">try</span> {
<a name="l00275"></a>00275                                 <span class="keyword">using</span> (fs) {
<a name="l00276"></a>00276                                     <span class="comment">//Run callback to write the cached data</span>
<a name="l00277"></a>00277                                     writeCallback(fs); <span class="comment">//Can throw any number of exceptions.</span>
<a name="l00278"></a>00278                                     finished = <span class="keyword">true</span>;
<a name="l00279"></a>00279                                 }
<a name="l00280"></a>00280                             } <span class="keywordflow">finally</span> {
<a name="l00281"></a>00281                                 <span class="comment">//Don&#39;t leave half-written files around.</span>
<a name="l00282"></a>00282                                 <span class="keywordflow">if</span> (!finished) <span class="keywordflow">try</span> { <span class="keywordflow">if</span> (File.Exists(physicalPath)) File.Delete(physicalPath);} <span class="keywordflow">catch</span> { }
<a name="l00283"></a>00283                             }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285                             DateTime createdUtc = DateTime.UtcNow;
<a name="l00286"></a>00286                             <span class="comment">//Update the write time to match - this is how we know whether they are in sync.</span>
<a name="l00287"></a>00287                             <span class="keywordflow">if</span> (hasModifiedDate) System.IO.File.SetLastWriteTimeUtc(physicalPath, sourceModifiedUtc);
<a name="l00288"></a>00288                             <span class="comment">//Set the created date, so we know the last time we updated the cache.s</span>
<a name="l00289"></a>00289                             System.IO.File.SetCreationTimeUtc(physicalPath, createdUtc);
<a name="l00290"></a>00290                             <span class="comment">//Update index</span>
<a name="l00291"></a>00291                             <span class="comment">//TODO: what should sourceModifiedUtc be when there is no modified date?</span>
<a name="l00292"></a>00292                             Index.setCachedFileInfo(relativePath, <span class="keyword">new</span> CachedFileInfo(sourceModifiedUtc, createdUtc, createdUtc));
<a name="l00293"></a>00293                             <span class="comment">//This was a cache miss</span>
<a name="l00294"></a>00294                             <span class="keywordflow">if</span> (result != null) result.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html#acd995c6ea0a45350729d72bb88af1f31" title="The result of the cache check.">Result</a> = <a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Miss;
<a name="l00295"></a>00295                         } <span class="keywordflow">catch</span> (IOException ex) {
<a name="l00296"></a>00296 
<a name="l00297"></a>00297                             <span class="keywordflow">if</span> ((!hasModifiedDate || hashModifiedDate) &amp;&amp; IsFileLocked(ex)) {
<a name="l00298"></a>00298                                 <span class="comment">//Somehow in between verifying the file didn&#39;t exist and trying to create it, the file was created and locked by someone else.</span>
<a name="l00299"></a>00299                                 <span class="comment">//When hashModifiedDate==true, we don&#39;t care what the file contains, we just want it to exist. If the file is available for </span>
<a name="l00300"></a>00300                                 <span class="comment">//reading within timeoutMs, simply do nothing and let the file be returned as a hit.</span>
<a name="l00301"></a>00301                                 Stopwatch waitForFile = <span class="keyword">new</span> Stopwatch();
<a name="l00302"></a>00302                                 <span class="keywordtype">bool</span> opened = <span class="keyword">false</span>;
<a name="l00303"></a>00303                                 <span class="keywordflow">while</span> (!opened &amp;&amp; waitForFile.ElapsedMilliseconds &lt; timeoutMs) {
<a name="l00304"></a>00304                                     waitForFile.Start();
<a name="l00305"></a>00305                                     <span class="keywordflow">try</span> {
<a name="l00306"></a>00306                                         <span class="keyword">using</span> (FileStream temp = <span class="keyword">new</span> FileStream(physicalPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
<a name="l00307"></a>00307                                             opened = <span class="keyword">true</span>;
<a name="l00308"></a>00308                                     } <span class="keywordflow">catch</span> (IOException iex) {
<a name="l00309"></a>00309                                         <span class="keywordflow">if</span> (IsFileLocked(iex))
<a name="l00310"></a>00310                                             Thread.Sleep((<span class="keywordtype">int</span>)Math.Min(30, Math.Round((<span class="keywordtype">float</span>)timeoutMs / 3.0)));
<a name="l00311"></a>00311                                         <span class="keywordflow">else</span> <span class="keywordflow">throw</span> iex;
<a name="l00312"></a>00312                                     }
<a name="l00313"></a>00313                                     waitForFile.Stop();
<a name="l00314"></a>00314                                 }
<a name="l00315"></a>00315                                 <span class="keywordflow">if</span> (!opened) <span class="keywordflow">throw</span>; <span class="comment">//By not throwing an exception, it is considered a hit by the rest of the code.</span>
<a name="l00316"></a>00316 
<a name="l00317"></a>00317                             } <span class="keywordflow">else</span> <span class="keywordflow">throw</span>;
<a name="l00318"></a>00318                         }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320                     }
<a name="l00321"></a>00321                 });
<a name="l00322"></a>00322         }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> IsFileLocked(IOException exception) {
<a name="l00325"></a>00325             <span class="keywordtype">int</span> errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) &amp; ((1 &lt;&lt; 16) - 1);
<a name="l00326"></a>00326             <span class="keywordflow">return</span> errorCode == 32 || errorCode == 33;
<a name="l00327"></a>00327         }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
