<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ImageResizer: ImageResizer.Util.PolygonMath Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="resizer-icon-64.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ImageResizer
   &#160;<span id="projectnumber">3.2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_image_resizer.html">ImageResizer</a>      </li>
      <li class="navelem"><a class="el" href="namespace_image_resizer_1_1_util.html">Util</a>      </li>
      <li class="navelem"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html">PolygonMath</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">ImageResizer.Util.PolygonMath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ImageResizer::Util::PolygonMath" -->
<p>Defines a collection of utility functions for manipulating polygons. These functions may be (re)moved in future releases; be prepared.  
 <a href="class_image_resizer_1_1_util_1_1_polygon_math.html#details">More...</a></p>

<p><a href="class_image_resizer_1_1_util_1_1_polygon_math-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcdcc55034ae68242ee53127ca7e56ce"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ForEachFunction" ref="afcdcc55034ae68242ee53127ca7e56ce" args="(object o)" -->
delegate object&#160;</td><td class="memItemRight" valign="bottom"><b>ForEachFunction</b> (object o)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a3bd9aa254e8639eb72e580d324f929b9">RoundPoints</a> (PointF[] a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of the specified array [not used].  <a href="#a3bd9aa254e8639eb72e580d324f929b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[,]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a47f8680ed6861066eb94516d5ad880bb">RoundPoints</a> (PointF[,] a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the elements of the specified array [not used].  <a href="#a47f8680ed6861066eb94516d5ad880bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ad1cd2d1a9e6f7cfb99df05710619beda">ForEach</a> (Array a, ForEachFunction func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the specified array by applying the specified function to each element.  <a href="#ad1cd2d1a9e6f7cfb99df05710619beda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac54dad57faaa778d20e08f721ef5784a">RotatePoly</a> (PointF[] poly, double degrees)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the specified polygon (or set of points) around the origin.  <a href="#ac54dad57faaa778d20e08f721ef5784a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#af69e7906a9414e524dcaa5d1004e7fb9">RotatePoly</a> (PointF[] poly, double degrees, PointF origin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the specified polygon (or set of points) around the origin.  <a href="#af69e7906a9414e524dcaa5d1004e7fb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95ca5afcd7e44086530b11518cf21fc9"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ScalePoints" ref="a95ca5afcd7e44086530b11518cf21fc9" args="(PointF[] poly, double xfactor, double yfactor, PointF origin)" -->
static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><b>ScalePoints</b> (PointF[] poly, double xfactor, double yfactor, PointF origin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a817329b4186934aa803b58be36076e37"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ScalePoint" ref="a817329b4186934aa803b58be36076e37" args="(PointF point, double xfactor, double yfactor, PointF origin)" -->
static PointF&#160;</td><td class="memItemRight" valign="bottom"><b>ScalePoint</b> (PointF point, double xfactor, double yfactor, PointF origin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac49aeb808917493b95d26e6e36183285">ToPoly</a> (RectangleF rect)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a clockwise array of points on the rectangle. Point 0 is top-left.  <a href="#ac49aeb808917493b95d26e6e36183285"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a1df0960d03c39a5714cdb0d56fc78bdf">NormalizePoly</a> (PointF[] poly)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the polygon so that the upper-left corner of its bounding box is located at 0,0.  <a href="#a1df0960d03c39a5714cdb0d56fc78bdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ae5f59da838ebfab5227354f8e736293a">RotateVector</a> (PointF v, double radians)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the specified point around the origin.  <a href="#ae5f59da838ebfab5227354f8e736293a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a08fe05d7eee9205b846e2fa89a5af0c7">RotateVector</a> (PointF v, double radians, PointF origin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ab2b4aa5d372c5aec8a17f342a47283bc">ChangeMagnitude</a> (PointF v, float length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modified version of the specified vector with the desired length.  <a href="#ab2b4aa5d372c5aec8a17f342a47283bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RectangleF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a2a0699cc81aa9335505c77939c6ba4bd">GetBoundingBox</a> (PointF[] points)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bounding box for the specified set of points.  <a href="#a2a0699cc81aa9335505c77939c6ba4bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a89ce0723e0e08b995245e70f85cff44f">MovePoly</a> (PointF[] points, PointF offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modified version of the array, with each element being offset by the specified amount.  <a href="#a89ce0723e0e08b995245e70f85cff44f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a091c43453f558cb12f8f4f4e485a711d">ArraysEqual</a> (PointF[] a1, PointF[] a2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the member elements of the specified arrays match, and the arrays are of the same length.  <a href="#a091c43453f558cb12f8f4f4e485a711d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a28d60a0db031946a534a4efbc85e2728">getParallelogram</a> (PointF[] quad)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves element 4 to spot 3 and truncates to 3 elements. For compatiblity with Graphics.DrawImage.  <a href="#a28d60a0db031946a534a4efbc85e2728"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static SizeF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a02b9e3951484c2e1592c6eb8131d8405">getParallelogramSize</a> (PointF[] p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the width and height of the paralellogram.  <a href="#a02b9e3951484c2e1592c6eb8131d8405"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#acaed52aad96ad8a928214131b4ae0764">GetSubArray</a> (PointF[,] array, int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs a single-dimension array from a 2 dimensional array, using the specified primary index.  <a href="#acaed52aad96ad8a928214131b4ae0764"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Brush&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a49bdd248873f97ae365d23f2f751de3a">GenerateRadialBrush</a> (Color inner, Color outer, PointF pt, float width)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates a radial brush using a high-rez PathGradientBrush.  <a href="#a49bdd248873f97ae365d23f2f751de3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static SizeF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a0495fc6849c286b9f880c900d1b66e7d">ScaleInside</a> (SizeF inner, SizeF bounding)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales 'inner' to fit inside 'bounding' while maintaining aspect ratio. Upscales and downscales.  <a href="#a0495fc6849c286b9f880c900d1b66e7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static SizeF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a63ca79f538e9c19e38f14ad57de06958">ScaleOutside</a> (SizeF innerBounds, SizeF outer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales 'outer' to be equal or larger than 'innerBounds' while maintaining aspect ratio. Upscales and downscales.  <a href="#a63ca79f538e9c19e38f14ad57de06958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static SizeF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aaccb0b4261dc176f5ad25b4bb09fd55f">DownScaleInside</a> (SizeF inner, SizeF bounding)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales 'inner' to fit inside 'bounding' while maintaining aspect ratio. Only downscales.  <a href="#aaccb0b4261dc176f5ad25b4bb09fd55f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a98c83ada594ba88b34d97d26176f8ada">FitsInside</a> (SizeF inner, SizeF outer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if 'inner' fits inside or equals 'outer'.  <a href="#a98c83ada594ba88b34d97d26176f8ada"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[,]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9533ccbfea8b33beaea2fb9dd3f38004">GetCorners</a> (PointF[] poly, float width)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of parallelograms. These parallelgrams are the 'corners' outside each vertex in 'poly'. The adjacent edges are perpendicular to 'poly'. Point 1 of each parallelogram will match the respective point in 'poly' Points are clockwise.  <a href="#a9533ccbfea8b33beaea2fb9dd3f38004"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[,]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aa8fa6985cc7a9273a04210a0e19e319f">GetCorners</a> (PointF[] poly, float[] widths)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of parallelograms. These parallelgrams are the 'corners' outside each vertex in 'poly'. The adjacent edges are perpendicular to 'poly'. Point 1 of each parallelogram will match the respective point in 'poly' Points are clockwise.  <a href="#aa8fa6985cc7a9273a04210a0e19e319f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[,]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aa48b557a348396e67330676ac38f369c">GetSides</a> (PointF[] poly, float width)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of parallelograms. These parallelgrams are the 'sides' bounding the polygon. Points are clockwise. Point 1 is the top-left outer point, point 2 the top-right, point 3 the bottom-right, and point 4 the bottom-left.  <a href="#aa48b557a348396e67330676ac38f369c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a062fe5752402710804fe0368016df808">InflatePoly</a> (PointF[] poly, float offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands all sides on the specified polygon by the specified offset. Assumes the polygon is concave. Returns a new polygon.  <a href="#a062fe5752402710804fe0368016df808"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ab5f9635239a1c350ca7aa829d1fcfcbf">InflatePoly</a> (PointF[] poly, float[] offsets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands all sides on the specified polygon by the specified offsets. Assumes the polygon is concave. Returns a new polygon.  <a href="#ab5f9635239a1c350ca7aa829d1fcfcbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aeac5d0934fa58e4d0898c061697d567d">CenterInside</a> (PointF[] inner, PointF[] outer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves 'inner' so that the center of its bounding box equals the center of the bounding box of 'outer'.  <a href="#aeac5d0934fa58e4d0898c061697d567d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RectangleF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a0c8647a23cf986b9def6f0934e72e275">CenterInside</a> (SizeF size, RectangleF bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rectangle of size 'size' with a center matching that of bounds.  <a href="#a0c8647a23cf986b9def6f0934e72e275"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Rectangle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a61b50db80ba6c732565d07ef6163c0a0">ToRectangle</a> (RectangleF r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a floating-point rectangle to an integer rectangle using System.Round.  <a href="#a61b50db80ba6c732565d07ef6163c0a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae803c4e4be59a729e43019e8c4e5485b"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::RoundPoints" ref="ae803c4e4be59a729e43019e8c4e5485b" args="(SizeF sizeF)" -->
static Size&#160;</td><td class="memItemRight" valign="bottom"><b>RoundPoints</b> (SizeF sizeF)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RectangleF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac55469f83724581600d27eabd617c582">AlignWith</a> (RectangleF obj, RectangleF container, ContentAlignment align)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the specified rectangle object with its reference ('container') rectangle using the specified alignment. The container can be smaller than 'obj'.  <a href="#ac55469f83724581600d27eabd617c582"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a25285403f324ed9f8bf7f44c4f13afbe">AlignWith</a> (PointF[] obj, PointF[] container, ContentAlignment align)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the specified polygon with its container (reference) polygon using the specified alignment. The container can be smaller than 'obj'.  <a href="#a25285403f324ed9f8bf7f44c4f13afbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a826b109164045c010e8458296f566b2c">Average</a> (PointF a, PointF b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a point equidistant beweteen A and B.  <a href="#a826b109164045c010e8458296f566b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a6a28a2a5551836ef6fbc3dc5db592f74">IsUnrotated</a> (PointF[] a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the specified 4 points are not rotated - that each point shares either the x or y coordinate with the previous point.  <a href="#a6a28a2a5551836ef6fbc3dc5db592f74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a0ca59a6970387e9157091eed76789844">GetShortestPair</a> (PointF[] poly)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the shortest line segment in the given polygon.  <a href="#a0ca59a6970387e9157091eed76789844"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ab8532ae5b7883d9a019a5bf1c9308c17">Dist</a> (PointF a, PointF b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two points.  <a href="#ab8532ae5b7883d9a019a5bf1c9308c17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9ebf3d2f01749ccafc6babc589cecd4d">NormalizeTo90Intervals</a> (double d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the given angle to a positive multiple of 90 degrees between 0 and 270.  <a href="#a9ebf3d2f01749ccafc6babc589cecd4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad44349a1cd0f60a0b6f55fb9284ad83a"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::CombineFlipAndRotate" ref="ad44349a1cd0f60a0b6f55fb9284ad83a" args="(RotateFlipType flip, double angle)" -->
static RotateFlipType&#160;</td><td class="memItemRight" valign="bottom"><b>CombineFlipAndRotate</b> (RotateFlipType flip, double angle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RotateFlipType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#af4561654d597d5c300b0c9097743e230">CombineFlipAndRotate</a> (<a class="el" href="namespace_image_resizer.html#ae28e0dd90e308cbc414def9313e66362">FlipMode</a> flip, double angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the given flipping info and rotation angle into a RotateFlipType value. Rotation angle will snap to nearest 90-degree multiple.  <a href="#af4561654d597d5c300b0c9097743e230"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RectangleF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a1816d2cd0df332902b2e40beef049da0">GetCroppingRectangle</a> (double[] cropValues, double xunits, double yunits, SizeF imageSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for converting custom crop rectangle coordinates into a valid cropping rectangle. Positive values are relative to 0,0, negative values relative to width, height. X2 and Y2 values of 0 become width and height respectively.  <a href="#a1816d2cd0df332902b2e40beef049da0"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Defines a collection of utility functions for manipulating polygons. These functions may be (re)moved in future releases; be prepared. </p>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00013">13</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac55469f83724581600d27eabd617c582"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::AlignWith" ref="ac55469f83724581600d27eabd617c582" args="(RectangleF obj, RectangleF container, ContentAlignment align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static RectangleF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac55469f83724581600d27eabd617c582">ImageResizer.Util.PolygonMath.AlignWith</a> </td>
          <td>(</td>
          <td class="paramtype">RectangleF&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RectangleF&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentAlignment&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the specified rectangle object with its reference ('container') rectangle using the specified alignment. The container can be smaller than 'obj'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
    <tr><td class="paramname">container</td><td></td></tr>
    <tr><td class="paramname">align</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00578">578</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00895">ImageResizer.ImageBuilder.LayoutImage()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                         {
            <span class="keywordflow">if</span> (align == ContentAlignment.BottomLeft || align == ContentAlignment.MiddleLeft || align == ContentAlignment.TopLeft)
                obj.X = container.X;
            <span class="keywordflow">if</span> (align == ContentAlignment.BottomCenter || align == ContentAlignment.MiddleCenter || align == ContentAlignment.TopCenter)
                obj.X = container.X + (container.Width - obj.Width) / 2;
            <span class="keywordflow">if</span> (align == ContentAlignment.BottomRight || align == ContentAlignment.MiddleRight || align == ContentAlignment.TopRight)
                obj.X = container.X + (container.Width - obj.Width);
            <span class="keywordflow">if</span> (align == ContentAlignment.TopLeft || align == ContentAlignment.TopCenter || align == ContentAlignment.TopRight)
                obj.Y = container.Y;
            <span class="keywordflow">if</span> (align == ContentAlignment.MiddleLeft || align == ContentAlignment.MiddleCenter || align == ContentAlignment.MiddleRight)
                obj.Y = container.Y + (container.Height - obj.Height) / 2;
            <span class="keywordflow">if</span> (align == ContentAlignment.BottomLeft || align == ContentAlignment.BottomCenter || align == ContentAlignment.BottomRight)
                obj.Y = container.Y + (container.Height - obj.Height);

            <span class="keywordflow">return</span> obj;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a25285403f324ed9f8bf7f44c4f13afbe"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::AlignWith" ref="a25285403f324ed9f8bf7f44c4f13afbe" args="(PointF[] obj, PointF[] container, ContentAlignment align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac55469f83724581600d27eabd617c582">ImageResizer.Util.PolygonMath.AlignWith</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentAlignment&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the specified polygon with its container (reference) polygon using the specified alignment. The container can be smaller than 'obj'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
    <tr><td class="paramname">container</td><td></td></tr>
    <tr><td class="paramname">align</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00601">601</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                   {
            RectangleF origBounds = PolygonMath.GetBoundingBox(obj);
            RectangleF newBounds = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac55469f83724581600d27eabd617c582" title="Aligns the specified rectangle object with its reference (&#39;container&#39;) rectangle using the specified ...">AlignWith</a>(PolygonMath.GetBoundingBox(obj), PolygonMath.GetBoundingBox(container), align);
            <span class="keywordflow">return</span> PolygonMath.MovePoly(obj, <span class="keyword">new</span> PointF(newBounds.X - origBounds.X, newBounds.Y - origBounds.Y));
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a091c43453f558cb12f8f4f4e485a711d"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ArraysEqual" ref="a091c43453f558cb12f8f4f4e485a711d" args="(PointF[] a1, PointF[] a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Boolean <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a091c43453f558cb12f8f4f4e485a711d">ImageResizer.Util.PolygonMath.ArraysEqual</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the member elements of the specified arrays match, and the arrays are of the same length. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td></td></tr>
    <tr><td class="paramname">a2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00256">256</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00711">ImageResizer.ImageBuilder.RenderBackground()</a>.</p>
<div class="fragment"><pre class="fragment">        {

            <span class="keywordflow">if</span> (a1.Length != a2.Length) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; a1.Length; i++)
            {
                <span class="keywordflow">if</span> (a1[i] != a2[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            }
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a826b109164045c010e8458296f566b2c"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::Average" ref="a826b109164045c010e8458296f566b2c" args="(PointF a, PointF b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a826b109164045c010e8458296f566b2c">ImageResizer.Util.PolygonMath.Average</a> </td>
          <td>(</td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a point equidistant beweteen A and B. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00613">613</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00789">ImageResizer.ImageBuilder.RenderBorder()</a>.</p>
<div class="fragment"><pre class="fragment">                                                         {
            <span class="keywordflow">return</span> <span class="keyword">new</span> PointF((a.X + b.X) / 2, (a.Y + b.Y) / 2);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="aeac5d0934fa58e4d0898c061697d567d"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::CenterInside" ref="aeac5d0934fa58e4d0898c061697d567d" args="(PointF[] inner, PointF[] outer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aeac5d0934fa58e4d0898c061697d567d">ImageResizer.Util.PolygonMath.CenterInside</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>outer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves 'inner' so that the center of its bounding box equals the center of the bounding box of 'outer'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inner</td><td></td></tr>
    <tr><td class="paramname">outer</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00537">537</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            RectangleF inBox = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a2a0699cc81aa9335505c77939c6ba4bd" title="Returns a bounding box for the specified set of points.">GetBoundingBox</a>(inner);
            RectangleF outBox = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a2a0699cc81aa9335505c77939c6ba4bd" title="Returns a bounding box for the specified set of points.">GetBoundingBox</a>(outer);
           
            <span class="keywordflow">return</span> <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a89ce0723e0e08b995245e70f85cff44f" title="Returns a modified version of the array, with each element being offset by the specified amount...">MovePoly</a>(<a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a1df0960d03c39a5714cdb0d56fc78bdf" title="Moves the polygon so that the upper-left corner of its bounding box is located at 0...">NormalizePoly</a>(inner), <span class="keyword">new</span> PointF((outBox.Width - inBox.Width) / 2 + outBox.X,
                                                    (outBox.Height - inBox.Height) / 2 + outBox.Y));
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a0c8647a23cf986b9def6f0934e72e275"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::CenterInside" ref="a0c8647a23cf986b9def6f0934e72e275" args="(SizeF size, RectangleF bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static RectangleF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aeac5d0934fa58e4d0898c061697d567d">ImageResizer.Util.PolygonMath.CenterInside</a> </td>
          <td>(</td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RectangleF&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a rectangle of size 'size' with a center matching that of bounds. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00551">551</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                                             {
            <span class="keywordflow">return</span> <span class="keyword">new</span> RectangleF(bounds.Width / 2 + bounds.X - (size.Width / 2), bounds.Height / 2 + bounds.Y - (size.Height / 2), size.Width, size.Height);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="ab2b4aa5d372c5aec8a17f342a47283bc"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ChangeMagnitude" ref="ab2b4aa5d372c5aec8a17f342a47283bc" args="(PointF v, float length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ab2b4aa5d372c5aec8a17f342a47283bc">ImageResizer.Util.PolygonMath.ChangeMagnitude</a> </td>
          <td>(</td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a modified version of the specified vector with the desired length. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">length</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00205">205</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="keywordtype">double</span> curLength = Math.Sqrt((v.X * v.X) + (v.Y * v.Y));
            <span class="keywordtype">float</span> factor = (float)(length / curLength);
            <span class="keywordflow">return</span> <span class="keyword">new</span> PointF(v.X * factor, v.Y * factor);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="af4561654d597d5c300b0c9097743e230"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::CombineFlipAndRotate" ref="af4561654d597d5c300b0c9097743e230" args="(FlipMode flip, double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static RotateFlipType ImageResizer.Util.PolygonMath.CombineFlipAndRotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_image_resizer.html#ae28e0dd90e308cbc414def9313e66362">FlipMode</a>&#160;</td>
          <td class="paramname"><em>flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combines the given flipping info and rotation angle into a RotateFlipType value. Rotation angle will snap to nearest 90-degree multiple. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flip</td><td></td></tr>
    <tr><td class="paramname">angle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00686">686</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                       {
            angle = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9ebf3d2f01749ccafc6babc589cecd4d" title="Normalizes the given angle to a positive multiple of 90 degrees between 0 and 270.">NormalizeTo90Intervals</a>(angle);
            <span class="keywordflow">if</span> (flip == <a class="code" href="namespace_image_resizer.html#ae28e0dd90e308cbc414def9313e66362" title="Horizontal and vertical flipping. Convertible to System.Drawing.RotateFlipType by casting...">FlipMode</a>.None) {
                <span class="keywordflow">return</span> (RotateFlipType)(int)(angle / 90);
            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flip == <a class="code" href="namespace_image_resizer.html#ae28e0dd90e308cbc414def9313e66362" title="Horizontal and vertical flipping. Convertible to System.Drawing.RotateFlipType by casting...">FlipMode</a>.X) {
                <span class="keywordflow">return</span> (RotateFlipType)(int)(4 + (angle / 90));
            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flip == <a class="code" href="namespace_image_resizer.html#ae28e0dd90e308cbc414def9313e66362" title="Horizontal and vertical flipping. Convertible to System.Drawing.RotateFlipType by casting...">FlipMode</a>.Y) {
                <span class="keywordflow">if</span> (angle == 0) <span class="keywordflow">return</span> (RotateFlipType)6;
                <span class="keywordflow">if</span> (angle == 90) <span class="keywordflow">return</span> (RotateFlipType)7;
                <span class="keywordflow">if</span> (angle == 180) <span class="keywordflow">return</span> (RotateFlipType)4;
                <span class="keywordflow">if</span> (angle == 270) <span class="keywordflow">return</span> (RotateFlipType)5;
            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flip == <a class="code" href="namespace_image_resizer.html#ae28e0dd90e308cbc414def9313e66362" title="Horizontal and vertical flipping. Convertible to System.Drawing.RotateFlipType by casting...">FlipMode</a>.XY) {
                <span class="keywordflow">if</span> (angle == 0) <span class="keywordflow">return</span> (RotateFlipType)2;
                <span class="keywordflow">if</span> (angle == 90) <span class="keywordflow">return</span> (RotateFlipType)3;
                <span class="keywordflow">if</span> (angle == 180) <span class="keywordflow">return</span> (RotateFlipType)0;
                <span class="keywordflow">if</span> (angle == 270) <span class="keywordflow">return</span> (RotateFlipType)1;
            } <span class="keywordflow">else</span> {
                <span class="keywordflow">throw</span> <span class="keyword">new</span> ArgumentException(<span class="stringliteral">&quot;Invalid FlipMode value &quot;</span> + flip.ToString());
            }
            <span class="keywordflow">throw</span> <span class="keyword">new</span> ArgumentException(<span class="stringliteral">&quot;Invalid angle value &quot;</span> + angle.ToString());
        }
</pre></div>
</div>
</div>
<a class="anchor" id="ab8532ae5b7883d9a019a5bf1c9308c17"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::Dist" ref="ab8532ae5b7883d9a019a5bf1c9308c17" args="(PointF a, PointF b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ab8532ae5b7883d9a019a5bf1c9308c17">ImageResizer.Util.PolygonMath.Dist</a> </td>
          <td>(</td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the distance between two points. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pointF</td><td></td></tr>
    <tr><td class="paramname">pointF_2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00649">649</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                      {
            <span class="keywordflow">return</span> Math.Sqrt((b.X - a.X) * (b.X - a.X) + (b.Y - a.Y) * (b.Y - a.Y));
        }
</pre></div>
</div>
</div>
<a class="anchor" id="aaccb0b4261dc176f5ad25b4bb09fd55f"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::DownScaleInside" ref="aaccb0b4261dc176f5ad25b4bb09fd55f" args="(SizeF inner, SizeF bounding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static SizeF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aaccb0b4261dc176f5ad25b4bb09fd55f">ImageResizer.Util.PolygonMath.DownScaleInside</a> </td>
          <td>(</td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>bounding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales 'inner' to fit inside 'bounding' while maintaining aspect ratio. Only downscales. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inner</td><td></td></tr>
    <tr><td class="paramname">bounding</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00388">388</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            SizeF result = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a0495fc6849c286b9f880c900d1b66e7d" title="Scales &#39;inner&#39; to fit inside &#39;bounding&#39; while maintaining aspect ratio. Upscales and downscales...">ScaleInside</a>(inner, bounding);
            <span class="keywordflow">if</span> (result.Width &gt; inner.Width || result.Height &gt; inner.Height) <span class="keywordflow">return</span> inner;
            <span class="keywordflow">else</span> <span class="keywordflow">return</span> result;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a98c83ada594ba88b34d97d26176f8ada"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::FitsInside" ref="a98c83ada594ba88b34d97d26176f8ada" args="(SizeF inner, SizeF outer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a98c83ada594ba88b34d97d26176f8ada">ImageResizer.Util.PolygonMath.FitsInside</a> </td>
          <td>(</td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>outer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if 'inner' fits inside or equals 'outer'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inner</td><td></td></tr>
    <tr><td class="paramname">outer</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00400">400</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00895">ImageResizer.ImageBuilder.LayoutImage()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="keywordflow">if</span> (inner.Width &gt; outer.Width) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            <span class="keywordflow">if</span> (inner.Height &gt; outer.Height) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="ad1cd2d1a9e6f7cfb99df05710619beda"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ForEach" ref="ad1cd2d1a9e6f7cfb99df05710619beda" args="(Array a, ForEachFunction func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ad1cd2d1a9e6f7cfb99df05710619beda">ImageResizer.Util.PolygonMath.ForEach</a> </td>
          <td>(</td>
          <td class="paramtype">Array&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForEachFunction&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modifies the specified array by applying the specified function to each element. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">func</td><td>object delegate(object o){}</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00057">57</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="keywordtype">long</span>[] ix = <span class="keyword">new</span> <span class="keywordtype">long</span>[a.Rank];
            <span class="comment">//Init index</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ix.Length;i++) ix[i] = a.GetLowerBound(i);

            <span class="comment">//Loop through all items</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; a.LongLength; i++){
                a.SetValue(func(a.GetValue(ix)),ix);

                <span class="comment">//Increment ix, the index</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ix.Length; j++)
                {
                    <span class="keywordflow">if</span> (ix[j] &lt; a.GetUpperBound(j))
                    {
                        ix[j]++;
                        <span class="keywordflow">break</span>; <span class="comment">//We&#39;re done incrementing.</span>
                    }
                    <span class="keywordflow">else</span>
                    {
                        <span class="comment">//Ok, reset this one and increment the next.</span>
                        ix[j] = a.GetLowerBound(j);
                        <span class="comment">//If this is the last dimension, assert</span>
                        <span class="comment">//that we are at the last element</span>
                        <span class="keywordflow">if</span> (j == ix.Length - 1)
                        {
                            <span class="keywordflow">if</span> (i &lt; a.LongLength - 1) <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception();
                        }
                        <span class="keywordflow">continue</span>;
                    }
                }
            }
            <span class="keywordflow">return</span>;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a49bdd248873f97ae365d23f2f751de3a"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GenerateRadialBrush" ref="a49bdd248873f97ae365d23f2f751de3a" args="(Color inner, Color outer, PointF pt, float width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Brush <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a49bdd248873f97ae365d23f2f751de3a">ImageResizer.Util.PolygonMath.GenerateRadialBrush</a> </td>
          <td>(</td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approximates a radial brush using a high-rez PathGradientBrush. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inner</td><td></td></tr>
    <tr><td class="paramname">outer</td><td></td></tr>
    <tr><td class="paramname">pt</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00315">315</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_drop_shadow_8cs_source.html#l00088">ImageResizer.Plugins.Basic.DropShadow.DrawOuterGradient()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="comment">//This should approximate one outer point per pixel.</span>
            PointF[] path = <span class="keyword">new</span> PointF[(int)Math.Round(width * 2 * Math.PI) + 1];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; path.Length - 1; i++)
            {
                <span class="keywordtype">double</span> radians = ((double)i - width) / width; <span class="comment">//calculate the radians at this index.</span>
                <span class="comment">//Calculate a point based off the radians.</span>
                path[i] = <span class="keyword">new</span> PointF((<span class="keywordtype">float</span>)(Math.Sin(radians) * width + pt.X), (<span class="keywordtype">float</span>)(Math.Cos(radians) * width + pt.Y));
            }
            path[path.Length - 1] = path[0]; <span class="comment">//Loop back to complete the circle.</span>

            PathGradientBrush b = <span class="keyword">new</span> PathGradientBrush(path);
            b.CenterColor = inner;
            b.CenterPoint = pt;
            b.WrapMode = WrapMode.Clamp;
            <span class="comment">//All outer colors are the same.</span>
            Color[] colors = <span class="keyword">new</span> Color[path.Length];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; colors.Length; i++) colors[i] = outer;
            b.SurroundColors = colors;
            b.SetSigmaBellShape(1);
            <span class="keywordflow">return</span> b;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a2a0699cc81aa9335505c77939c6ba4bd"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GetBoundingBox" ref="a2a0699cc81aa9335505c77939c6ba4bd" args="(PointF[] points)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static RectangleF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a2a0699cc81aa9335505c77939c6ba4bd">ImageResizer.Util.PolygonMath.GetBoundingBox</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a bounding box for the specified set of points. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00218">218</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_polygon_math_8cs_source.html#l00601">ImageResizer.Util.PolygonMath.AlignWith()</a>, <a class="el" href="_free_image_builder_8cs_source.html#l00123">ImageResizer.Plugins.FreeImageBuilder.FreeImageBuilderPlugin.buildFiBitmap()</a>, <a class="el" href="_wic_builder_8cs_source.html#l00098">ImageResizer.Plugins.WicBuilder.WicBuilderPlugin.BuildJobWic()</a>, <a class="el" href="_layer_8cs_source.html#l00167">ImageResizer.Plugins.Watermark.Layer.CalculateLayerCoordinates()</a>, <a class="el" href="_layout_builder_8cs_source.html#l00127">ImageResizer.Resizing.LayoutBuilder.GetBoundingBox()</a>, <a class="el" href="_trial_8cs_source.html#l00054">ImageResizer.Plugins.Basic.Trial.PreFlushChanges()</a>, <a class="el" href="_detection_plugin_8cs_source.html#l00052">ImageResizer.Plugins.RedEye.DetectionPlugin.Render()</a>, and <a class="el" href="_speed_or_quality_8cs_source.html#l00025">ImageResizer.Plugins.Basic.SpeedOrQuality.RenderImage()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="keywordtype">float</span> left = <span class="keywordtype">float</span>.MaxValue;
            <span class="keywordtype">float</span> top = <span class="keywordtype">float</span>.MaxValue;
            <span class="keywordtype">float</span> right = <span class="keywordtype">float</span>.MinValue;
            <span class="keywordtype">float</span> bottom = <span class="keywordtype">float</span>.MinValue;
            <span class="keywordflow">foreach</span> (PointF f <span class="keywordflow">in</span> points)
            {
                <span class="keywordflow">if</span> (f.X &lt; left) left = f.X;
                <span class="keywordflow">if</span> (f.X &gt; right) right = f.X;
                <span class="keywordflow">if</span> (f.Y &lt; top) top = f.Y;
                <span class="keywordflow">if</span> (f.Y &gt; bottom) bottom = f.Y;
            }
            <span class="keywordflow">return</span> <span class="keyword">new</span> RectangleF(left, top, right - left, bottom - top);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a9533ccbfea8b33beaea2fb9dd3f38004"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GetCorners" ref="a9533ccbfea8b33beaea2fb9dd3f38004" args="(PointF[] poly, float width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [,] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9533ccbfea8b33beaea2fb9dd3f38004">ImageResizer.Util.PolygonMath.GetCorners</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of parallelograms. These parallelgrams are the 'corners' outside each vertex in 'poly'. The adjacent edges are perpendicular to 'poly'. Point 1 of each parallelogram will match the respective point in 'poly' Points are clockwise. </p>
<p>TODO - some rounding issues going on, not exact numbers here </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00416">416</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_drop_shadow_8cs_source.html#l00088">ImageResizer.Plugins.Basic.DropShadow.DrawOuterGradient()</a>, and <a class="el" href="_image_builder_8cs_source.html#l00789">ImageResizer.ImageBuilder.RenderBorder()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="comment">//Build the widths array.</span>
            <span class="keywordtype">float</span>[] widths = <span class="keyword">new</span> <span class="keywordtype">float</span>[poly.Length];
            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; widths.Length;i++) widths[i] = width;
            <span class="comment">//Call</span>
            <span class="keywordflow">return</span> <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9533ccbfea8b33beaea2fb9dd3f38004" title="Returns an array of parallelograms. These parallelgrams are the &#39;corners&#39; outside each vertex in &#39;pol...">GetCorners</a>(poly,widths);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="aa8fa6985cc7a9273a04210a0e19e319f"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GetCorners" ref="aa8fa6985cc7a9273a04210a0e19e319f" args="(PointF[] poly, float[] widths)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [,] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9533ccbfea8b33beaea2fb9dd3f38004">ImageResizer.Util.PolygonMath.GetCorners</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]&#160;</td>
          <td class="paramname"><em>widths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of parallelograms. These parallelgrams are the 'corners' outside each vertex in 'poly'. The adjacent edges are perpendicular to 'poly'. Point 1 of each parallelogram will match the respective point in 'poly' Points are clockwise. </p>
<p>Each float in widths[] corresponds to the point in poly[]. This is the distance to go perpendicularly from the line beween poly[i] and poly[i +1].</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
    <tr><td class="paramname">widths</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00436">436</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="keywordflow">if</span> (poly.Length != widths.Length) <span class="keywordflow">throw</span> <span class="keyword">new</span> ArgumentException(<span class="stringliteral">&quot;Arrays &#39;poly&#39; and &#39;widths&#39; must have the same number of elements&quot;</span>);

            PointF[,] corners = <span class="keyword">new</span> PointF[poly.Length, 4];
            <span class="keywordtype">int</span> end = (poly.Length - 1); <span class="comment">//the last index in the array</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; poly.Length; i++)
            {

                <span class="comment">//Get next an prev points. Wrap around. Clockwise.</span>
                PointF next = (i &lt; end) ? poly[i + 1] : poly[i - end];
                PointF prev = (i &gt; 0) ? poly[i - 1] : poly[i + end];
                PointF current = poly[i];

                <span class="keywordtype">float</span> prevWidth = (i &gt; 0) ? widths[i-1] : widths[i + end];
                <span class="keywordtype">float</span> width = widths[i];

                <span class="comment">//Radians = pi/(180*degrees)</span>
                <span class="comment">//Degrees = radians*180/pi</span>
                <span class="comment">//Get vectors perpendicular to next and prev, with lengths of &#39;offset&#39;.</span>
                PointF pP = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ab2b4aa5d372c5aec8a17f342a47283bc" title="Returns a modified version of the specified vector with the desired length.">ChangeMagnitude</a>(
                    <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ae5f59da838ebfab5227354f8e736293a" title="Rotates the specified point around the origin.">RotateVector</a>(<span class="keyword">new</span> PointF(prev.X - current.X, prev.Y - current.Y), Math.PI / 2) <span class="comment">//rotate 90 clockwise.</span>
                    , prevWidth); <span class="comment">//scale to offset length.</span>

                PointF pN = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ab2b4aa5d372c5aec8a17f342a47283bc" title="Returns a modified version of the specified vector with the desired length.">ChangeMagnitude</a>(
                    <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ae5f59da838ebfab5227354f8e736293a" title="Rotates the specified point around the origin.">RotateVector</a>(<span class="keyword">new</span> PointF(next.X - current.X, next.Y - current.Y), Math.PI / -2) <span class="comment">//rotate 90 counter-clockwise.</span>
                    , width); <span class="comment">//scale to offset length.</span>

                <span class="comment">//Add to get points 2 and 4 of the parallelogram.</span>
                <span class="comment">//Add both to get point 3</span>
                corners[i, 0] = current;
                corners[i, 1] = <span class="keyword">new</span> PointF(current.X + pP.X, current.Y + pP.Y);
                corners[i, 2] = <span class="keyword">new</span> PointF(current.X + pP.X + pN.X, current.Y + pP.Y + pN.Y);
                corners[i, 3] = <span class="keyword">new</span> PointF(current.X + pN.X, current.Y + pN.Y);
            }
            <span class="keywordflow">return</span> corners;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a1816d2cd0df332902b2e40beef049da0"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GetCroppingRectangle" ref="a1816d2cd0df332902b2e40beef049da0" args="(double[] cropValues, double xunits, double yunits, SizeF imageSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static RectangleF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a1816d2cd0df332902b2e40beef049da0">ImageResizer.Util.PolygonMath.GetCroppingRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">double[]&#160;</td>
          <td class="paramname"><em>cropValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xunits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yunits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>imageSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used for converting custom crop rectangle coordinates into a valid cropping rectangle. Positive values are relative to 0,0, negative values relative to width, height. X2 and Y2 values of 0 become width and height respectively. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cropValues</td><td>An array of 4 elements defining x1, y1, x2, and y2 of the cropping rectangle</td></tr>
    <tr><td class="paramname">xunits</td><td>The width x1 and x2 are relative to</td></tr>
    <tr><td class="paramname">yunits</td><td>The height y1 and y2 are relative to</td></tr>
    <tr><td class="paramname">imageSize</td><td>The size of the uncropped image</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00718">718</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                          {
            RectangleF defValue = <span class="keyword">new</span> RectangleF(<span class="keyword">new</span> PointF(0, 0), imageSize);
            <span class="keywordtype">double</span>[] c = cropValues;

            <span class="comment">//Step 2, Apply units to values, resolving against imageSize</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; c.Length; i++) {
                <span class="keywordtype">bool</span> xvalue = i % 2 == 0;
                <span class="keywordflow">if</span> (xvalue &amp;&amp; xunits != 0) c[i] *= (imageSize.Width / xunits);
                <span class="keywordflow">if</span> (!xvalue &amp;&amp; xunits != 0) c[i] *= (imageSize.Height / yunits);

                <span class="comment">//Prohibit values larger than imageSize</span>
                <span class="keywordflow">if</span> (xvalue &amp;&amp; c[i] &gt; imageSize.Width) c[i] = imageSize.Width;
                <span class="keywordflow">if</span> (!xvalue &amp;&amp; c[i] &gt; imageSize.Height) c[i] = imageSize.Height;
            }

            <span class="comment">//Step 3, expand width/height crop to 4-value crop (not currently used)</span>
            <span class="keywordflow">if</span> (c.Length == 2) {
                <span class="keywordflow">if</span> (c[0] &lt; 1 || c[1] &lt; 1) <span class="keywordflow">return</span> defValue; <span class="comment">//We can&#39;t do anything with negative values here</span>
                <span class="comment">//Center horizontally and vertically.</span>
                <span class="keywordtype">double</span> x = (imageSize.Width - c[0]) / 2;
                <span class="keywordtype">double</span> y = (imageSize.Height - c[1]) / 2;

                c = <span class="keyword">new</span> <span class="keywordtype">double</span>[] { x, y, x + c[0], y + c[1] };
            }

            <span class="keywordtype">double</span> x1 = c[0], y1 = c[1], x2 = c[2], y2 = c[3];

            <span class="comment">//allow negative offsets </span>
            <span class="keywordflow">if</span> (x1 &lt; 0) x1 += imageSize.Width;
            <span class="keywordflow">if</span> (y1 &lt; 0) y1 += imageSize.Height;
            <span class="keywordflow">if</span> (x2 &lt;= 0) x2 += imageSize.Width;
            <span class="keywordflow">if</span> (y2 &lt;= 0) y2 += imageSize.Height;


            <span class="comment">//Require box stay in bounds.</span>
            <span class="keywordflow">if</span> (x1 &lt; 0) x1 = 0; <span class="keywordflow">if</span> (x2 &lt; 0) x2 = 0;
            <span class="keywordflow">if</span> (y1 &lt; 0) y1 = 0; <span class="keywordflow">if</span> (y2 &lt; 0) y2 = 0;
            <span class="keywordflow">if</span> (x1 &gt; imageSize.Width) x1 = imageSize.Width;
            <span class="keywordflow">if</span> (x2 &gt; imageSize.Width) x2 = imageSize.Width;
            <span class="keywordflow">if</span> (y1 &gt; imageSize.Height) y1 = imageSize.Height;
            <span class="keywordflow">if</span> (y2 &gt; imageSize.Height) y2 = imageSize.Height;

            <span class="comment">//Require positive width and height.</span>
            <span class="keywordflow">if</span> (x2 &lt;= x1 || y2 &lt;= y1) {
                <span class="comment">//Use original dimensions - can&#39;t recover from negative width or height in cropping rectangle</span>
                <span class="keywordflow">return</span> <span class="keyword">new</span> RectangleF(<span class="keyword">new</span> PointF(0, 0), imageSize);
            }

            <span class="keywordflow">return</span> <span class="keyword">new</span> RectangleF((<span class="keywordtype">float</span>)x1, (<span class="keywordtype">float</span>)y1, (<span class="keywordtype">float</span>)(x2 - x1), (<span class="keywordtype">float</span>)(y2 - y1));
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a28d60a0db031946a534a4efbc85e2728"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::getParallelogram" ref="a28d60a0db031946a534a4efbc85e2728" args="(PointF[] quad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a28d60a0db031946a534a4efbc85e2728">ImageResizer.Util.PolygonMath.getParallelogram</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves element 4 to spot 3 and truncates to 3 elements. For compatiblity with Graphics.DrawImage. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quad</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00273">273</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_speed_or_quality_8cs_source.html#l00025">ImageResizer.Plugins.Basic.SpeedOrQuality.RenderImage()</a>, and <a class="el" href="_image_builder_8cs_source.html#l00768">ImageResizer.ImageBuilder.RenderImage()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            PointF[] p = <span class="keyword">new</span> PointF[3];
            p[0] = quad[0];
            p[1] = quad[1];
            p[2] = quad[3];
            <span class="keywordflow">return</span> p;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a02b9e3951484c2e1592c6eb8131d8405"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::getParallelogramSize" ref="a02b9e3951484c2e1592c6eb8131d8405" args="(PointF[] p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static SizeF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a02b9e3951484c2e1592c6eb8131d8405">ImageResizer.Util.PolygonMath.getParallelogramSize</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the width and height of the paralellogram. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00287">287</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_free_image_resizer_8cs_source.html#l00043">ImageResizer.Plugins.FreeImageScaling.FreeImageScalingPlugin.PreRenderImage()</a>, and <a class="el" href="_seam_carving_plugin_8cs_source.html#l00092">ImageResizer.Plugins.SeamCarving.SeamCarvingPlugin.PreRenderImage()</a>.</p>
<div class="fragment"><pre class="fragment">                                                             {
            <span class="keywordtype">double</span> width = Math.Sqrt(Math.Pow(p[0].X - p[1].X,2) + Math.Pow(p[0].Y - p[1].Y,2));
            <span class="keywordtype">double</span> height = Math.Sqrt(Math.Pow(p[1].X - p[2].X,2) + Math.Pow(p[1].Y - p[2].Y,2));
            <span class="keywordflow">return</span> <span class="keyword">new</span> SizeF((<span class="keywordtype">float</span>)width, (<span class="keywordtype">float</span>)height);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a0ca59a6970387e9157091eed76789844"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GetShortestPair" ref="a0ca59a6970387e9157091eed76789844" args="(PointF[] poly)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a0ca59a6970387e9157091eed76789844">ImageResizer.Util.PolygonMath.GetShortestPair</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the length of the shortest line segment in the given polygon. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00632">632</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                            {
            PointF last = poly[poly.Length - 1];
            <span class="keywordtype">double</span> max = 0;
            <span class="keywordflow">foreach</span> (PointF p <span class="keywordflow">in</span> poly) {
                <span class="keywordtype">double</span> dist = Math.Sqrt((p.X - last.X) * (p.X - last.X) + (p.Y - last.Y) * (p.Y - last.Y));
                <span class="keywordflow">if</span> (dist &gt; max) max = dist;
                last = p;
            }
            <span class="keywordflow">return</span> max;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="aa48b557a348396e67330676ac38f369c"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GetSides" ref="aa48b557a348396e67330676ac38f369c" args="(PointF[] poly, float width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [,] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#aa48b557a348396e67330676ac38f369c">ImageResizer.Util.PolygonMath.GetSides</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of parallelograms. These parallelgrams are the 'sides' bounding the polygon. Points are clockwise. Point 1 is the top-left outer point, point 2 the top-right, point 3 the bottom-right, and point 4 the bottom-left. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
    <tr><td class="paramname">width</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00480">480</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_drop_shadow_8cs_source.html#l00088">ImageResizer.Plugins.Basic.DropShadow.DrawOuterGradient()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="comment">//Just grab the sides between the corners.</span>
            PointF[,] corners = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9533ccbfea8b33beaea2fb9dd3f38004" title="Returns an array of parallelograms. These parallelgrams are the &#39;corners&#39; outside each vertex in &#39;pol...">GetCorners</a>(poly, width);
            PointF[,] sides = <span class="keyword">new</span> PointF[corners.GetUpperBound(0) + 1, 4];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= corners.GetUpperBound(0); i++)
            {
                <span class="keywordtype">int</span> next = (i &lt; corners.GetUpperBound(0)) ? i + 1 : i - corners.GetUpperBound(0);
                sides[i, 0] = corners[i, 3];
                sides[i, 3] = corners[i, 0];
                sides[i, 1] = corners[next, 1];
                sides[i, 2] = corners[next, 0];
            }
            <span class="keywordflow">return</span> sides;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="acaed52aad96ad8a928214131b4ae0764"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::GetSubArray" ref="acaed52aad96ad8a928214131b4ae0764" args="(PointF[,] array, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#acaed52aad96ad8a928214131b4ae0764">ImageResizer.Util.PolygonMath.GetSubArray</a> </td>
          <td>(</td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>array</em>[,], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Grabs a single-dimension array from a 2 dimensional array, using the specified primary index. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td></td></tr>
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00300">300</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_drop_shadow_8cs_source.html#l00088">ImageResizer.Plugins.Basic.DropShadow.DrawOuterGradient()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            PointF[] sub = <span class="keyword">new</span> PointF[array.GetUpperBound(1) + 1];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; array.GetUpperBound(1) + 1; i++)
                sub[i] = array[index, i];
            <span class="keywordflow">return</span> sub;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a062fe5752402710804fe0368016df808"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::InflatePoly" ref="a062fe5752402710804fe0368016df808" args="(PointF[] poly, float offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a062fe5752402710804fe0368016df808">ImageResizer.Util.PolygonMath.InflatePoly</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands all sides on the specified polygon by the specified offset. Assumes the polygon is concave. Returns a new polygon. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00502">502</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_layout_builder_8cs_source.html#l00105">ImageResizer.Resizing.LayoutBuilder.AddRing()</a>, <a class="el" href="_drop_shadow_8cs_source.html#l00032">ImageResizer.Plugins.Basic.DropShadow.LayoutEffects()</a>, <a class="el" href="_image_builder_8cs_source.html#l00789">ImageResizer.ImageBuilder.RenderBorder()</a>, and <a class="el" href="_drop_shadow_8cs_source.html#l00053">ImageResizer.Plugins.Basic.DropShadow.RenderEffects()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            PointF[,] corners = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9533ccbfea8b33beaea2fb9dd3f38004" title="Returns an array of parallelograms. These parallelgrams are the &#39;corners&#39; outside each vertex in &#39;pol...">GetCorners</a>(poly, offset);
            PointF[] newPoly = <span class="keyword">new</span> PointF[poly.Length];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= corners.GetUpperBound(0); i++)
                newPoly[i] = corners[i, 2]; <span class="comment">//Just grab the outer corner</span>

            <span class="keywordflow">return</span> newPoly;

        }
</pre></div>
</div>
</div>
<a class="anchor" id="ab5f9635239a1c350ca7aa829d1fcfcbf"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::InflatePoly" ref="ab5f9635239a1c350ca7aa829d1fcfcbf" args="(PointF[] poly, float[] offsets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a062fe5752402710804fe0368016df808">ImageResizer.Util.PolygonMath.InflatePoly</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float[]&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands all sides on the specified polygon by the specified offsets. Assumes the polygon is concave. Returns a new polygon. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
    <tr><td class="paramname">offsets</td><td>An array the same size as poly[], with the distances to expand the edges. Edges are between i and i+1</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00520">520</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            PointF[,] corners = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9533ccbfea8b33beaea2fb9dd3f38004" title="Returns an array of parallelograms. These parallelgrams are the &#39;corners&#39; outside each vertex in &#39;pol...">GetCorners</a>(poly, offsets);
            PointF[] newPoly = <span class="keyword">new</span> PointF[poly.Length];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= corners.GetUpperBound(0); i++)
                newPoly[i] = corners[i, 2]; <span class="comment">//Just grab the outer corner</span>

            <span class="keywordflow">return</span> newPoly;

        }
</pre></div>
</div>
</div>
<a class="anchor" id="a6a28a2a5551836ef6fbc3dc5db592f74"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::IsUnrotated" ref="a6a28a2a5551836ef6fbc3dc5db592f74" args="(PointF[] a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a6a28a2a5551836ef6fbc3dc5db592f74">ImageResizer.Util.PolygonMath.IsUnrotated</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verifies that the specified 4 points are not rotated - that each point shares either the x or y coordinate with the previous point. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00620">620</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00711">ImageResizer.ImageBuilder.RenderBackground()</a>.</p>
<div class="fragment"><pre class="fragment">                                                   {
            PointF lastPoint = a[a.GetUpperBound(0)];
            <span class="keywordflow">foreach</span> (PointF p <span class="keywordflow">in</span> a) {
                <span class="keywordflow">if</span> (p.X != lastPoint.X &amp;&amp; p.Y != lastPoint.Y) <span class="keywordflow">return</span> <span class="keyword">false</span>;
                lastPoint = p;
            }
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a89ce0723e0e08b995245e70f85cff44f"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::MovePoly" ref="a89ce0723e0e08b995245e70f85cff44f" args="(PointF[] points, PointF offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a89ce0723e0e08b995245e70f85cff44f">ImageResizer.Util.PolygonMath.MovePoly</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a modified version of the array, with each element being offset by the specified amount. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td></td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00239">239</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_polygon_math_8cs_source.html#l00601">ImageResizer.Util.PolygonMath.AlignWith()</a>, <a class="el" href="_drop_shadow_8cs_source.html#l00032">ImageResizer.Plugins.Basic.DropShadow.LayoutEffects()</a>, <a class="el" href="_layout_builder_8cs_source.html#l00152">ImageResizer.Resizing.LayoutBuilder.Normalize()</a>, <a class="el" href="_polygon_math_8cs_source.html#l00151">ImageResizer.Util.PolygonMath.NormalizePoly()</a>, and <a class="el" href="_layout_builder_8cs_source.html#l00182">ImageResizer.Resizing.LayoutBuilder.Shift()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            PointF[] pts = <span class="keyword">new</span> PointF[points.Length];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; points.Length; i++)
            {
                pts[i].X = points[i].X + offset.X;
                pts[i].Y = points[i].Y + offset.Y;
            }
            <span class="keywordflow">return</span> pts;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a1df0960d03c39a5714cdb0d56fc78bdf"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::NormalizePoly" ref="a1df0960d03c39a5714cdb0d56fc78bdf" args="(PointF[] poly)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a1df0960d03c39a5714cdb0d56fc78bdf">ImageResizer.Util.PolygonMath.NormalizePoly</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the polygon so that the upper-left corner of its bounding box is located at 0,0. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00151">151</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            RectangleF box = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a2a0699cc81aa9335505c77939c6ba4bd" title="Returns a bounding box for the specified set of points.">GetBoundingBox</a>(poly);
            <span class="keywordflow">return</span> PolygonMath.MovePoly(poly, <span class="keyword">new</span> PointF(-box.X, -box.Y));
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a9ebf3d2f01749ccafc6babc589cecd4d"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::NormalizeTo90Intervals" ref="a9ebf3d2f01749ccafc6babc589cecd4d" args="(double d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a9ebf3d2f01749ccafc6babc589cecd4d">ImageResizer.Util.PolygonMath.NormalizeTo90Intervals</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes the given angle to a positive multiple of 90 degrees between 0 and 270. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00658">658</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                              {
            d = d % 360;
            <span class="keywordflow">if</span> (d &lt; 0) d += 360;

            <span class="keywordflow">if</span> (d &gt;= 315 &amp;&amp; d &lt; 360) <span class="keywordflow">return</span> 0;
            <span class="keywordflow">if</span> (d &gt;= 0 &amp;&amp; d &lt; 45) <span class="keywordflow">return</span> 0;
            <span class="keywordflow">if</span> (d &gt;= 45 &amp;&amp; d &lt; 135) <span class="keywordflow">return</span> 90;
            <span class="keywordflow">if</span> (d &gt;= 135 &amp;&amp; d &lt; 225) <span class="keywordflow">return</span> 180;
            <span class="keywordflow">if</span> (d &gt;= 225 &amp;&amp; d &lt; 315) <span class="keywordflow">return</span> 270;

            <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception(<span class="stringliteral">&quot;Impossible&quot;</span>);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="ac54dad57faaa778d20e08f721ef5784a"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::RotatePoly" ref="ac54dad57faaa778d20e08f721ef5784a" args="(PointF[] poly, double degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac54dad57faaa778d20e08f721ef5784a">ImageResizer.Util.PolygonMath.RotatePoly</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified polygon (or set of points) around the origin. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
    <tr><td class="paramname">degrees</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00098">98</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_layout_builder_8cs_source.html#l00141">ImageResizer.Resizing.LayoutBuilder.Rotate()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            PointF[] pts = <span class="keyword">new</span> PointF[poly.Length];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; poly.Length; i++)
                pts[i] = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ae5f59da838ebfab5227354f8e736293a" title="Rotates the specified point around the origin.">RotateVector</a>(poly[i], degrees * Math.PI / 180);
            <span class="keywordflow">return</span> pts;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="af69e7906a9414e524dcaa5d1004e7fb9"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::RotatePoly" ref="af69e7906a9414e524dcaa5d1004e7fb9" args="(PointF[] poly, double degrees, PointF origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac54dad57faaa778d20e08f721ef5784a">ImageResizer.Util.PolygonMath.RotatePoly</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified polygon (or set of points) around the origin. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td></td></tr>
    <tr><td class="paramname">degrees</td><td></td></tr>
    <tr><td class="paramname">origin</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00113">113</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                        {
            PointF[] pts = <span class="keyword">new</span> PointF[poly.Length];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; poly.Length; i++)
                pts[i] = <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ae5f59da838ebfab5227354f8e736293a" title="Rotates the specified point around the origin.">RotateVector</a>(poly[i], degrees * Math.PI / 180,origin);
            <span class="keywordflow">return</span> pts;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="ae5f59da838ebfab5227354f8e736293a"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::RotateVector" ref="ae5f59da838ebfab5227354f8e736293a" args="(PointF v, double radians)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ae5f59da838ebfab5227354f8e736293a">ImageResizer.Util.PolygonMath.RotateVector</a> </td>
          <td>(</td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified point around the origin. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">radians</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00162">162</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
<span class="comment">/*</span>
<span class="comment">             *  2D Rotation</span>
<span class="comment">             *  A point &lt;x,y&gt; can be rotated around the origin &lt;0,0&gt; by running it through the following equations </span>
<span class="comment">             * to get the new point &lt;x&#39;,y&#39;&gt; :</span>
<span class="comment">             * x&#39; = cos(theta)*x - sin(theta)*y //cos(90) or cos(-90) = 0</span>
<span class="comment">             * y&#39; = sin(theta)*x + cos(theta)*y //sin(90) or sin(-90) = +/- 1</span>
<span class="comment">*/</span>
            <span class="keywordflow">return</span> <span class="keyword">new</span> PointF(
                (<span class="keywordtype">float</span>)(Math.Cos(radians) * v.X - Math.Sin(radians) * v.Y),
                (<span class="keywordtype">float</span>)(Math.Sin(radians) * v.X + Math.Cos(radians) * v.Y));
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a08fe05d7eee9205b846e2fa89a5af0c7"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::RotateVector" ref="a08fe05d7eee9205b846e2fa89a5af0c7" args="(PointF v, double radians, PointF origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ae5f59da838ebfab5227354f8e736293a">ImageResizer.Util.PolygonMath.RotateVector</a> </td>
          <td>(</td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotates the specified point around the specified origin.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">radians</td><td></td></tr>
    <tr><td class="paramname">origin</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00183">183</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
<span class="comment">/*</span>
<span class="comment">                         * 2D Rotation</span>
<span class="comment">             *  A point &lt;x,y&gt; can be rotated around the origin &lt;0,0&gt; by running it through the following equations </span>
<span class="comment">             * to get the new point &lt;x&#39;,y&#39;&gt; :</span>
<span class="comment">             * x&#39; = cos(theta)*x - sin(theta)*y //cos(90) or cos(-90) = 0</span>
<span class="comment">             * y&#39; = sin(theta)*x + cos(theta)*y //sin(90) or sin(-90) = +/- 1</span>
<span class="comment">*/</span>
            <span class="keywordflow">return</span> <span class="keyword">new</span> PointF(
                (<span class="keywordtype">float</span>)(Math.Cos(radians) * (v.X - origin.X) - Math.Sin(radians) * (v.Y - origin.Y)) + origin.X,
                (float)(Math.Sin(radians) *  (v.X - origin.X) + Math.Cos(radians) *  (v.Y - origin.Y)) + origin.Y);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a3bd9aa254e8639eb72e580d324f929b9"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::RoundPoints" ref="a3bd9aa254e8639eb72e580d324f929b9" args="(PointF[] a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a3bd9aa254e8639eb72e580d324f929b9">ImageResizer.Util.PolygonMath.RoundPoints</a> </td>
          <td>(</td>
          <td class="paramtype">PointF[]&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rounds the elements of the specified array [not used]. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00020">20</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00671">ImageResizer.ImageBuilder.EndLayout()</a>, and <a class="el" href="_image_builder_8cs_source.html#l00895">ImageResizer.ImageBuilder.LayoutImage()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            
            <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ad1cd2d1a9e6f7cfb99df05710619beda" title="Modifies the specified array by applying the specified function to each element.">ForEach</a>(a, delegate(<span class="keywordtype">object</span> o){
                PointF p = (PointF)o;
                p.X = (float)Math.Round(p.X);
                p.Y = (float)Math.Round(p.Y);
                <span class="keywordflow">return</span> p;
            });
            <span class="keywordflow">return</span> a;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a47f8680ed6861066eb94516d5ad880bb"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::RoundPoints" ref="a47f8680ed6861066eb94516d5ad880bb" args="(PointF[,] a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [,] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a3bd9aa254e8639eb72e580d324f929b9">ImageResizer.Util.PolygonMath.RoundPoints</a> </td>
          <td>(</td>
          <td class="paramtype">PointF&#160;</td>
          <td class="paramname"><em>a</em>[,]</td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rounds the elements of the specified array [not used]. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00037">37</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>
<div class="fragment"><pre class="fragment">        {
            
            <a class="code" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ad1cd2d1a9e6f7cfb99df05710619beda" title="Modifies the specified array by applying the specified function to each element.">ForEach</a>(a, delegate(<span class="keywordtype">object</span> o)
            {
                PointF p = (PointF)o;
                p.X = (float)Math.Round(p.X);
                p.Y = (float)Math.Round(p.Y);
                <span class="keywordflow">return</span> p;
            });
            <span class="keywordflow">return</span> a;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a0495fc6849c286b9f880c900d1b66e7d"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ScaleInside" ref="a0495fc6849c286b9f880c900d1b66e7d" args="(SizeF inner, SizeF bounding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static SizeF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a0495fc6849c286b9f880c900d1b66e7d">ImageResizer.Util.PolygonMath.ScaleInside</a> </td>
          <td>(</td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>bounding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales 'inner' to fit inside 'bounding' while maintaining aspect ratio. Upscales and downscales. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inner</td><td></td></tr>
    <tr><td class="paramname">bounding</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00345">345</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00895">ImageResizer.ImageBuilder.LayoutImage()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="keywordtype">double</span> innerRatio = inner.Width / inner.Height;
            <span class="keywordtype">double</span> outerRatio = bounding.Width / bounding.Height;

            <span class="keywordflow">if</span> (outerRatio &gt; innerRatio)
            {
                <span class="comment">//Width is wider - so bound by height.</span>
                <span class="keywordflow">return</span> <span class="keyword">new</span> SizeF((<span class="keywordtype">float</span>)(innerRatio * bounding.Height), (<span class="keywordtype">float</span>)(bounding.Height));
            }
            <span class="keywordflow">else</span>
            {
                <span class="comment">//Height is higher, or aspect ratios are identical.</span>
                <span class="keywordflow">return</span> <span class="keyword">new</span> SizeF((<span class="keywordtype">float</span>)(bounding.Width), (<span class="keywordtype">float</span>)(bounding.Width / innerRatio));
            }
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a63ca79f538e9c19e38f14ad57de06958"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ScaleOutside" ref="a63ca79f538e9c19e38f14ad57de06958" args="(SizeF innerBounds, SizeF outer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static SizeF <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a63ca79f538e9c19e38f14ad57de06958">ImageResizer.Util.PolygonMath.ScaleOutside</a> </td>
          <td>(</td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>innerBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeF&#160;</td>
          <td class="paramname"><em>outer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales 'outer' to be equal or larger than 'innerBounds' while maintaining aspect ratio. Upscales and downscales. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">innerBounds</td><td></td></tr>
    <tr><td class="paramname">outer</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00368">368</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_free_image_resizer_8cs_source.html#l00043">ImageResizer.Plugins.FreeImageScaling.FreeImageScalingPlugin.PreRenderImage()</a>, and <a class="el" href="_seam_carving_plugin_8cs_source.html#l00092">ImageResizer.Plugins.SeamCarving.SeamCarvingPlugin.PreRenderImage()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                         {
            <span class="keywordtype">double</span> innerRatio = innerBounds.Width / innerBounds.Height;
            <span class="keywordtype">double</span> outerRatio = outer.Width / outer.Height;

            <span class="keywordflow">if</span> (outerRatio &gt; innerRatio) {
                <span class="comment">//Width is wider - so bound by height.</span>
                <span class="keywordflow">return</span> <span class="keyword">new</span> SizeF((<span class="keywordtype">float</span>)(outerRatio * innerBounds.Height), (<span class="keywordtype">float</span>)(innerBounds.Height));
            } <span class="keywordflow">else</span> {
                <span class="comment">//Height is higher, or aspect ratios are identical.</span>
                <span class="keywordflow">return</span> <span class="keyword">new</span> SizeF((<span class="keywordtype">float</span>)(innerBounds.Width), (<span class="keywordtype">float</span>)(innerBounds.Width / outerRatio));
            }
        }
</pre></div>
</div>
</div>
<a class="anchor" id="ac49aeb808917493b95d26e6e36183285"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ToPoly" ref="ac49aeb808917493b95d26e6e36183285" args="(RectangleF rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PointF [] <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#ac49aeb808917493b95d26e6e36183285">ImageResizer.Util.PolygonMath.ToPoly</a> </td>
          <td>(</td>
          <td class="paramtype">RectangleF&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a clockwise array of points on the rectangle. Point 0 is top-left. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00137">137</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_image_builder_8cs_source.html#l00895">ImageResizer.ImageBuilder.LayoutImage()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            PointF[] r = <span class="keyword">new</span> PointF[4];
            r[0] = rect.Location;
            r[1] = <span class="keyword">new</span> PointF(rect.Right, rect.Top);
            r[2] = <span class="keyword">new</span> PointF(rect.Right, rect.Bottom);
            r[3] = <span class="keyword">new</span> PointF(rect.Left, rect.Bottom);
            <span class="keywordflow">return</span> r;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a61b50db80ba6c732565d07ef6163c0a0"></a><!-- doxytag: member="ImageResizer::Util::PolygonMath::ToRectangle" ref="a61b50db80ba6c732565d07ef6163c0a0" args="(RectangleF r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Rectangle <a class="el" href="class_image_resizer_1_1_util_1_1_polygon_math.html#a61b50db80ba6c732565d07ef6163c0a0">ImageResizer.Util.PolygonMath.ToRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">RectangleF&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rounds a floating-point rectangle to an integer rectangle using System.Round. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_polygon_math_8cs_source.html#l00561">561</a> of file <a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a>.</p>

<p>Referenced by <a class="el" href="_wic_builder_8cs_source.html#l00098">ImageResizer.Plugins.WicBuilder.WicBuilderPlugin.BuildJobWic()</a>, <a class="el" href="_image_builder_8cs_source.html#l00895">ImageResizer.ImageBuilder.LayoutImage()</a>, and <a class="el" href="_speed_or_quality_8cs_source.html#l00025">ImageResizer.Plugins.Basic.SpeedOrQuality.RenderImage()</a>.</p>
<div class="fragment"><pre class="fragment">        {
            <span class="keywordflow">return</span> <span class="keyword">new</span> Rectangle((<span class="keywordtype">int</span>)Math.Round(r.X), (int)Math.Round(r.Y), (int)Math.Round(r.Width),(int)Math.Round( r.Height));
        }
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Administrator/Documents/resizer/Core/Util/<a class="el" href="_polygon_math_8cs_source.html">PolygonMath.cs</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
