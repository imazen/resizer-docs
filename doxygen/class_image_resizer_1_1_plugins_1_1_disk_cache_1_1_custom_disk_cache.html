<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ImageResizer: ImageResizer.Plugins.DiskCache.CustomDiskCache Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="resizer-icon-64.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ImageResizer
   &#160;<span id="projectnumber">3.2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_image_resizer.html">ImageResizer</a>      </li>
      <li class="navelem"><a class="el" href="namespace_image_resizer_1_1_plugins.html">Plugins</a>      </li>
      <li class="navelem"><a class="el" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html">DiskCache</a>      </li>
      <li class="navelem"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html">CustomDiskCache</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#events">Events</a>  </div>
  <div class="headertitle">
<div class="title">ImageResizer.Plugins.DiskCache.CustomDiskCache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ImageResizer::Plugins::DiskCache::CustomDiskCache" -->
<p>Handles access to a disk-based file cache. Handles locking and versioning. Supports subfolders for scalability.  
 <a href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for ImageResizer.Plugins.DiskCache.CustomDiskCache:</div>
<div class="dyncontent">
<div class="center"><img src="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache__coll__graph.png" border="0" usemap="#_image_resizer_8_plugins_8_disk_cache_8_custom_disk_cache_coll__map" alt="Collaboration graph"/></div>
<map name="_image_resizer_8_plugins_8_disk_cache_8_custom_disk_cache_coll__map" id="_image_resizer_8_plugins_8_disk_cache_8_custom_disk_cache_coll__map">
<area shape="rect" id="node2" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger_provider.html" title="ImageResizer.Configuration.Logging.ILoggerProvider" alt="" coords="6,5,770,51"/><area shape="rect" id="node4" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread&#45;safe." alt="" coords="47,105,729,151"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad65b2baa1bc893dba09861249a3d3e3a"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::CustomDiskCache" ref="ad65b2baa1bc893dba09861249a3d3e3a" args="(ILoggerProvider lp, string physicalCachePath, int subfolders, bool hashModifiedDate)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>CustomDiskCache</b> (<a class="el" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger_provider.html">ILoggerProvider</a> lp, string physicalCachePath, int subfolders, bool hashModifiedDate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34d95dbe768305e32f057f3a0dd4c8c0"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::CustomDiskCache" ref="a34d95dbe768305e32f057f3a0dd4c8c0" args="(ILoggerProvider lp, string physicalCachePath, int subfolders, bool hashModifiedDate, long asyncMaxQueuedBytes)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>CustomDiskCache</b> (<a class="el" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger_provider.html">ILoggerProvider</a> lp, string physicalCachePath, int subfolders, bool hashModifiedDate, long asyncMaxQueuedBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794">GetCachedFile</a> (string keyBasis, string extension, ResizeImageDelegate writeCallback, DateTime sourceModifiedUtc, int timeoutMs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries to cache the data and return the path.  <a href="#a262bea285f70f5a8a05732e1e6a8c794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a43cbe092ec6180f6f30fff0c7dd4d270">GetCachedFile</a> (string keyBasis, string extension, ResizeImageDelegate writeCallback, DateTime sourceModifiedUtc, int timeoutMs, bool asynchronous)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">May return either a physical file name or a MemoryStream with the data. Faster than GetCachedFile, as writes are (usually) asynchronous. If the write queue is full, the write is forced to be synchronous again. Identical to <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794" title="If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries t...">GetCachedFile()</a> when asynchronous=false.  <a href="#a43cbe092ec6180f6f30fff0c7dd4d270"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f4fe512032fd04d911f145ad3ade5b9"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::physicalCachePath" ref="a0f4fe512032fd04d911f145ad3ade5b9" args="" -->
string&#160;</td><td class="memItemRight" valign="bottom"><b>physicalCachePath</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48d5ad622ee02de3b956062f90d8ec8f"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::subfolders" ref="a48d5ad622ee02de3b956062f90d8ec8f" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>subfolders</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99370251f138568a0c4f9cb87ab56810"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::hashModifiedDate" ref="a99370251f138568a0c4f9cb87ab56810" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hashModifiedDate</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ac55f72a17ab2fc5f9422fee526ce5"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::lp" ref="af4ac55f72a17ab2fc5f9422fee526ce5" args="" -->
<a class="el" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger_provider.html">ILoggerProvider</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lp</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7314ff3f464f08ce4da211187774fc68"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::locks" ref="a7314ff3f464f08ce4da211187774fc68" args="" -->
<a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a>&#160;</td><td class="memItemRight" valign="bottom"><b>locks</b> = new <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80305f0f1c1c2e6f8306c2f9bc8ca860"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::queueLocks" ref="a80305f0f1c1c2e6f8306c2f9bc8ca860" args="" -->
<a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a>&#160;</td><td class="memItemRight" valign="bottom"><b>queueLocks</b> = new <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a>()</td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23470af46dacc7e6a575f0cfd67f642b"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::PhysicalCachePath" ref="a23470af46dacc7e6a575f0cfd67f642b" args="" -->
string&#160;</td><td class="memItemRight" valign="bottom"><b>PhysicalCachePath</b><code> [get]</code></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#ad6e28a6622b78c69d52b492ac1cd84dc">Locks</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides string-based locking for file write access.  <a href="#ad6e28a6622b78c69d52b492ac1cd84dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a43828a7d93f9850dd2497a48013cbcd6">QueueLocks</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides string-based locking for image resizing (not writing, just processing). Prevents duplication of efforts in asynchronous mode, where 'Locks' is not being used.  <a href="#a43828a7d93f9850dd2497a48013cbcd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html">AsyncWriteCollection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a561a334189a8a0169f3e204bdb825502">CurrentWrites</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all the queued and in-progress writes to the cache.  <a href="#a561a334189a8a0169f3e204bdb825502"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_index.html">CacheIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#abe47e92a8f0bee35ac7b08a02777b4ef">Index</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an in-memory index of the cache.  <a href="#abe47e92a8f0bee35ac7b08a02777b4ef"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="events"></a>
Events</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CacheResultHandler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a3c6eebab73d41d608b5638aa0d992806">CacheResultReturned</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fired immediately before GetCachedFile return the result value.  <a href="#a3c6eebab73d41d608b5638aa0d992806"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Handles access to a disk-based file cache. Handles locking and versioning. Supports subfolders for scalability. </p>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00020">20</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a262bea285f70f5a8a05732e1e6a8c794"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::GetCachedFile" ref="a262bea285f70f5a8a05732e1e6a8c794" args="(string keyBasis, string extension, ResizeImageDelegate writeCallback, DateTime sourceModifiedUtc, int timeoutMs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a> <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794">ImageResizer.Plugins.DiskCache.CustomDiskCache.GetCachedFile</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>keyBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResizeImageDelegate&#160;</td>
          <td class="paramname"><em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTime&#160;</td>
          <td class="paramname"><em>sourceModifiedUtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries to cache the data and return the path. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyBasis</td><td>The basis for the key. Should not include the modified date, that is handled inside the function.</td></tr>
    <tr><td class="paramname">extension</td><td>The extension to use for the cached file.</td></tr>
    <tr><td class="paramname">writeCallback</td><td>A method that accepts a Stream argument and writes the data to it.</td></tr>
    <tr><td class="paramname">sourceModifiedUtc</td><td>The modified date of the source file. Should be DateTime.MinValue if not available</td></tr>
    <tr><td class="paramname">timeoutMs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00090">90</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                                                          {
            <span class="keywordflow">return</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794" title="If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries t...">GetCachedFile</a>(keyBasis, extension, writeCallback, sourceModifiedUtc, timeoutMs, <span class="keyword">false</span>);
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a43cbe092ec6180f6f30fff0c7dd4d270"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::GetCachedFile" ref="a43cbe092ec6180f6f30fff0c7dd4d270" args="(string keyBasis, string extension, ResizeImageDelegate writeCallback, DateTime sourceModifiedUtc, int timeoutMs, bool asynchronous)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_result.html">CacheResult</a> <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794">ImageResizer.Plugins.DiskCache.CustomDiskCache.GetCachedFile</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>keyBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResizeImageDelegate&#160;</td>
          <td class="paramname"><em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DateTime&#160;</td>
          <td class="paramname"><em>sourceModifiedUtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asynchronous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>May return either a physical file name or a MemoryStream with the data. Faster than GetCachedFile, as writes are (usually) asynchronous. If the write queue is full, the write is forced to be synchronous again. Identical to <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a262bea285f70f5a8a05732e1e6a8c794" title="If the cached data exists and is up-to-date, returns the path to it. Otherwise, this function tries t...">GetCachedFile()</a> when asynchronous=false. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyBasis</td><td></td></tr>
    <tr><td class="paramname">extension</td><td></td></tr>
    <tr><td class="paramname">writeCallback</td><td></td></tr>
    <tr><td class="paramname">sourceModifiedUtc</td><td></td></tr>
    <tr><td class="paramname">timeoutMs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00106">106</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                                                                             {
            Stopwatch sw = null;
            <span class="keywordflow">if</span> (lp.Logger != null) { sw = <span class="keyword">new</span> Stopwatch(); sw.Start(); }


            <span class="keywordtype">bool</span> hasModifiedDate = !sourceModifiedUtc.Equals(DateTime.MinValue);


            <span class="comment">//Hash the modified date if needed.</span>
            <span class="keywordflow">if</span> (hashModifiedDate &amp;&amp; hasModifiedDate)
                keyBasis += <span class="stringliteral">&quot;|&quot;</span> + sourceModifiedUtc.Ticks.ToString(NumberFormatInfo.InvariantInfo);

            <span class="comment">//Relative to the cache directory. Not relative to the app or domain root</span>
            <span class="keywordtype">string</span> relativePath = <span class="keyword">new</span> UrlHasher().hash(keyBasis, subfolders, <span class="stringliteral">&quot;/&quot;</span>) + <span class="charliteral">&#39;.&#39;</span> + extension;

            <span class="comment">//Physical path</span>
            <span class="keywordtype">string</span> physicalPath = PhysicalCachePath.TrimEnd(<span class="charliteral">&#39;\\&#39;</span>, <span class="charliteral">&#39;/&#39;</span>) + System.IO.Path.DirectorySeparatorChar +
                    relativePath.Replace(<span class="charliteral">&#39;/&#39;</span>, System.IO.Path.DirectorySeparatorChar);


            CacheResult result = <span class="keyword">new</span> CacheResult(<a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Hit, physicalPath, relativePath);

            <span class="keywordtype">bool</span> asyncFailed = <span class="keyword">false</span>;

             <span class="comment">//On the first check, verify the file exists using System.IO directly (the last &#39;true&#39; parameter).</span>
            <span class="keywordflow">if</span> (!asynchronous) {
                <span class="comment">//On the first check, verify the file exists using System.IO directly (the last &#39;true&#39; parameter)</span>
                <span class="comment">//May throw an IOException if the file cannot be opened, and is locked by an external processes for longer than timeoutMs. </span>
                <span class="comment">//This method may take longer than timeoutMs under absolute worst conditions. </span>
                <span class="keywordflow">if</span> (!TryWriteFile(result, physicalPath, relativePath, writeCallback, sourceModifiedUtc, timeoutMs, <span class="keyword">true</span>)) {
                    <span class="comment">//On failure</span>
                    result.Result = <a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Failed;
                }
            }<span class="keywordflow">else</span> <span class="keywordflow">if</span> ((!hasModifiedDate || hashModifiedDate) ? !<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#abe47e92a8f0bee35ac7b08a02777b4ef" title="Provides an in-memory index of the cache.">Index</a>.existsCertain(relativePath, physicalPath) : !<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#abe47e92a8f0bee35ac7b08a02777b4ef" title="Provides an in-memory index of the cache.">Index</a>.modifiedDateMatchesCertainExists(sourceModifiedUtc, relativePath, physicalPath)) {
                
                <span class="comment">//Looks like a miss. Let&#39;s enter a lock for the creation of the file. This is a different locking system than for writing to the file - far less contention, as it doesn&#39;t include the </span>
                <span class="comment">//This prevents two identical requests from duplicating efforts. Different requests don&#39;t lock.</span>

                <span class="comment">//Lock execution using relativePath as the sync basis. Ignore casing differences. This prevents duplicate entries in the write queue and wasted CPU/RAM usage.</span>
                <span class="keywordflow">if</span> (!<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a43828a7d93f9850dd2497a48013cbcd6" title="Provides string-based locking for image resizing (not writing, just processing). Prevents duplication...">QueueLocks</a>.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html#aba5ee5d1323568b30fc351151524ac0c" title="Attempts to execute the &#39;success&#39; callback inside a lock based on &#39;key&#39;. If successful, returns true. If the lock cannot be acquired within &#39;timoutMs&#39;, returns false In a worst-case scenario, it could take up to twice as long as &#39;timeoutMs&#39; to return false.">TryExecute</a>(relativePath.ToUpperInvariant(), timeoutMs,
                    delegate() {

                        <span class="comment">//Now, if the item we seek is in the queue, we have a memcached hit. If not, we should check the index. It&#39;s possible the item has been written to disk already.</span>
                        <span class="comment">//If both are a miss, we should see if there is enough room in the write queue. If not, switch to in-thread writing. </span>

                        <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a> t = <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a561a334189a8a0169f3e204bdb825502" title="Contains all the queued and in-progress writes to the cache.">CurrentWrites</a>.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html#a002c466579c94e379c32f7aabc675254" title="If the collection contains the specified item, it is returned. Otherwise, null is returned...">Get</a>(relativePath, sourceModifiedUtc);

                        <span class="keywordflow">if</span> (t != null) result.Data = t.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#a5955b11b1055470663e3ad3c04451e56" title="Wraps the data in a readonly MemoryStream so it can be accessed on another thread.">GetReadonlyStream</a>();

                        <span class="comment">//On the second check, use cached data for speed. The cached data should be updated if another thread updated a file (but not if another process did).</span>
                        <span class="keywordflow">if</span> (t == null &amp;&amp;
                            ((!hasModifiedDate || hashModifiedDate) ? !<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#abe47e92a8f0bee35ac7b08a02777b4ef" title="Provides an in-memory index of the cache.">Index</a>.exists(relativePath, physicalPath) : !<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#abe47e92a8f0bee35ac7b08a02777b4ef" title="Provides an in-memory index of the cache.">Index</a>.modifiedDateMatches(sourceModifiedUtc, relativePath, physicalPath))) {

                                result.Result = <a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Miss;
                            <span class="comment">//Still a miss, we even rechecked the filesystem. Write to memory.</span>
                            MemoryStream ms = <span class="keyword">new</span> MemoryStream(4096);  <span class="comment">//4K initial capacity is minimal, but this array will get copied around alot, better to underestimate.</span>
                            <span class="comment">//Read, resize, process, and encode the image. Lots of exceptions thrown here.</span>
                            writeCallback(ms);
                            ms.Position = 0;

                            <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a> w = <span class="keyword">new</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a>(<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a561a334189a8a0169f3e204bdb825502" title="Contains all the queued and in-progress writes to the cache.">CurrentWrites</a>,ms, physicalPath, relativePath, sourceModifiedUtc);
                            <span class="keywordflow">if</span> (<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a561a334189a8a0169f3e204bdb825502" title="Contains all the queued and in-progress writes to the cache.">CurrentWrites</a>.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html#a92b45565d75d0c9c9a0d56d5b11fcac0" title="Returns false when (a) the specified AsyncWrite value already exists, (b) the queue is full...">Queue</a>(w, delegate(<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html">AsyncWrite</a> job) {
                                <span class="keywordflow">try</span> {
                                    Stopwatch swio = <span class="keyword">new</span> Stopwatch();
                                    
                                    swio.Start();
                                    <span class="comment">//TODO: perhaps a different timeout?</span>
                                    <span class="keywordflow">if</span> (!TryWriteFile(null, job.PhysicalPath, job.RelativePath, delegate(Stream s) { ((MemoryStream)job.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#a5955b11b1055470663e3ad3c04451e56" title="Wraps the data in a readonly MemoryStream so it can be accessed on another thread.">GetReadonlyStream</a>()).WriteTo(s); }, job.ModifiedDateUtc, timeoutMs, <span class="keyword">true</span>)) {
                                        swio.Stop();
                                        <span class="comment">//We failed to lock the file.</span>
                                        <span class="keywordflow">if</span> (lp.Logger != null) 
                                            lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a2a3c0e13cb37d522b1dd8f4f1fdb669d" title="Writes the diagnostic message at the Warn level.">Warn</a>(<span class="stringliteral">&quot;Failed to flush async write, timeout exceeded after {1}ms - {0}&quot;</span>,  result.RelativePath, swio.ElapsedMilliseconds);
                                        
                                    } <span class="keywordflow">else</span> {
                                        swio.Stop();
                                        <span class="keywordflow">if</span> (lp.Logger != null)
                                            lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a5125ea275ed8c2dda55c6f8e9f082b97" title="Writes the diagnostic message at the Trace level.">Trace</a>(<span class="stringliteral">&quot;{0}ms: Async write started {1}ms after enqueue for {2}&quot;</span>, swio.ElapsedMilliseconds.ToString().PadLeft(4), DateTime.UtcNow.Subtract(w.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#add6b89ca915007089f9bebbfdfb82dee" title="Returns the UTC time this AsyncWrite object was created.">JobCreatedAt</a>).Subtract(swio.Elapsed).TotalMilliseconds, result.RelativePath);
                                    }

                                } <span class="keywordflow">catch</span> (Exception ex) {
                                    <span class="keywordflow">if</span> (lp.Logger != null) {
                                        lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a4502d6eee54e1e6a4fd7ae51e3c915b1" title="Writes the diagnostic message at the Error level.">Error</a>(<span class="stringliteral">&quot;Failed to flush async write, {0} {1}\n{2}&quot;</span>,ex.ToString(), result.RelativePath,ex.StackTrace);
                                    }
                                } <span class="keywordflow">finally</span> {
                                    <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a561a334189a8a0169f3e204bdb825502" title="Contains all the queued and in-progress writes to the cache.">CurrentWrites</a>.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html#aa245eff15b732e3caee328ad86a278a9" title="Removes the specified object based on its relativepath and modifieddateutc values.">Remove</a>(job); <span class="comment">//Remove from the queue, it&#39;s done or failed. </span>
                                }

                            })) {
                                <span class="comment">//We queued it! Send back a read-only memory stream</span>
                                result.Data = w.<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write.html#a5955b11b1055470663e3ad3c04451e56" title="Wraps the data in a readonly MemoryStream so it can be accessed on another thread.">GetReadonlyStream</a>();
                            } <span class="keywordflow">else</span> {
                                asyncFailed = <span class="keyword">false</span>;
                                <span class="comment">//We failed to queue it - either the ThreadPool was exhausted or we exceeded the MB limit for the write queue.</span>
                                <span class="comment">//Write the MemoryStream to disk using the normal method.</span>
                                <span class="comment">//This is nested inside a queuelock because if we failed here, the next one will also. Better to force it to wait until the file is written to disk.</span>
                                <span class="keywordflow">if</span> (!TryWriteFile(result, physicalPath, relativePath, delegate(Stream s) { ms.WriteTo(s); }, sourceModifiedUtc, timeoutMs, <span class="keyword">false</span>)) {
                                    <span class="keywordflow">if</span> (lp.Logger != null)
                                        lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a2a3c0e13cb37d522b1dd8f4f1fdb669d" title="Writes the diagnostic message at the Warn level.">Warn</a>(<span class="stringliteral">&quot;Failed to queue async write, also failed to lock for sync writing: {0}&quot;</span>, result.RelativePath);
                                        
                                }
                            }

                        }

                    })) {
                    <span class="comment">//On failure</span>
                    result.Result = <a class="code" href="namespace_image_resizer_1_1_plugins_1_1_disk_cache.html#afb29b25106a646c2ee694841e4b57fa8">CacheQueryResult</a>.Failed;
                }

            }
            <span class="keywordflow">if</span> (lp.Logger != null) {
                sw.Stop();
                lp.Logger.<a class="code" href="interface_image_resizer_1_1_configuration_1_1_logging_1_1_i_logger.html#a5125ea275ed8c2dda55c6f8e9f082b97" title="Writes the diagnostic message at the Trace level.">Trace</a>(<span class="stringliteral">&quot;{0}ms: {3}{1} for {2}, Key: {4}&quot;</span>, sw.ElapsedMilliseconds.ToString(NumberFormatInfo.InvariantInfo).PadLeft(4), result.Result.ToString(), result.RelativePath, asynchronous ? (asyncFailed ? <span class="stringliteral">&quot;Fallback to sync  &quot;</span> : <span class="stringliteral">&quot;Async &quot;</span>) : <span class="stringliteral">&quot;&quot;</span>, keyBasis);
            }
            <span class="comment">//Fire event</span>
            <span class="keywordflow">if</span> (<a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a3c6eebab73d41d608b5638aa0d992806" title="Fired immediately before GetCachedFile return the result value.">CacheResultReturned</a> != null) <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a3c6eebab73d41d608b5638aa0d992806" title="Fired immediately before GetCachedFile return the result value.">CacheResultReturned</a>(<span class="keyword">this</span>, result);
            <span class="keywordflow">return</span> result;
        }
</pre></div>
</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a561a334189a8a0169f3e204bdb825502"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::CurrentWrites" ref="a561a334189a8a0169f3e204bdb825502" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_async_1_1_async_write_collection.html">AsyncWriteCollection</a> <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a561a334189a8a0169f3e204bdb825502">ImageResizer.Plugins.DiskCache.CustomDiskCache.CurrentWrites</a><code> [get]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Contains all the queued and in-progress writes to the cache. </p>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00065">65</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="abe47e92a8f0bee35ac7b08a02777b4ef"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::Index" ref="abe47e92a8f0bee35ac7b08a02777b4ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_cache_index.html">CacheIndex</a> <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#abe47e92a8f0bee35ac7b08a02777b4ef">ImageResizer.Plugins.DiskCache.CustomDiskCache.Index</a><code> [get]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides an in-memory index of the cache. </p>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00075">75</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="ad6e28a6622b78c69d52b492ac1cd84dc"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::Locks" ref="ad6e28a6622b78c69d52b492ac1cd84dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a> <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#ad6e28a6622b78c69d52b492ac1cd84dc">ImageResizer.Plugins.DiskCache.CustomDiskCache.Locks</a><code> [get]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides string-based locking for file write access. </p>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00049">49</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>

</div>
</div>
<a class="anchor" id="a43828a7d93f9850dd2497a48013cbcd6"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::QueueLocks" ref="a43828a7d93f9850dd2497a48013cbcd6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">LockProvider</a> <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a43828a7d93f9850dd2497a48013cbcd6">ImageResizer.Plugins.DiskCache.CustomDiskCache.QueueLocks</a><code> [get]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides string-based locking for image resizing (not writing, just processing). Prevents duplication of efforts in asynchronous mode, where 'Locks' is not being used. </p>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00057">57</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>

</div>
</div>
<hr/><h2>Event Documentation</h2>
<a class="anchor" id="a3c6eebab73d41d608b5638aa0d992806"></a><!-- doxytag: member="ImageResizer::Plugins::DiskCache::CustomDiskCache::CacheResultReturned" ref="a3c6eebab73d41d608b5638aa0d992806" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CacheResultHandler <a class="el" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_custom_disk_cache.html#a3c6eebab73d41d608b5638aa0d992806">ImageResizer.Plugins.DiskCache.CustomDiskCache.CacheResultReturned</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fired immediately before GetCachedFile return the result value. </p>

<p>Definition at line <a class="el" href="_custom_disk_cache_8cs_source.html#l00042">42</a> of file <a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Administrator/Documents/resizer/Plugins/DiskCache/<a class="el" href="_custom_disk_cache_8cs_source.html">CustomDiskCache.cs</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
