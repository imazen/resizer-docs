<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ImageResizer: C:/Users/Administrator/Documents/resizer/Plugins/DiskCache/LockProvider.cs Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="resizer-icon-64.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ImageResizer
   &#160;<span id="projectnumber">3.2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">C:/Users/Administrator/Documents/resizer/Plugins/DiskCache/LockProvider.cs</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 ï»¿<span class="comment">/* Copyright (c) 2011 Nathanael Jones. See license.txt for your rights. */</span>
<a name="l00002"></a>00002 <span class="keyword">using</span> System;
<a name="l00003"></a>00003 <span class="keyword">using</span> System.Collections.Generic;
<a name="l00004"></a>00004 <span class="keyword">using</span> System.Text;
<a name="l00005"></a>00005 <span class="keyword">using</span> System.Threading;
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="keyword">namespace </span>ImageResizer.Plugins.DiskCache {
<a name="l00008"></a>00008 
<a name="l00009"></a>00009     <span class="keyword">public</span> delegate <span class="keywordtype">void</span> LockCallback();<span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    /// &lt;summary&gt;</span>
<a name="l00011"></a>00011 <span class="comment">    /// Provides locking based on a string key. </span>
<a name="l00012"></a>00012 <span class="comment">    /// Locks are local to the LockProvider instance.</span>
<a name="l00013"></a>00013 <span class="comment">    /// The class handles disposing of unused locks. Generally used for </span>
<a name="l00014"></a>00014 <span class="comment">    /// coordinating writes to files (of which there can be millions). </span>
<a name="l00015"></a>00015 <span class="comment">    /// Only keeps key/lock pairs in memory which are in use.</span>
<a name="l00016"></a>00016 <span class="comment">    /// Thread-safe.</span>
<a name="l00017"></a>00017 <span class="comment">    /// &lt;/summary&gt;</span>
<a name="l00018"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html">00018</a> <span class="comment"></span>    <span class="keyword">public</span> <span class="keyword">class </span><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html" title="Provides locking based on a string key. Locks are local to the LockProvider instance. The class handles disposing of unused locks. Generally used for coordinating writes to files (of which there can be millions). Only keeps key/lock pairs in memory which are in use. Thread-safe.">LockProvider</a> {
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00021"></a>00021 <span class="comment">        /// The only objects in this collection should be for open files. </span>
<a name="l00022"></a>00022 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00023"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html#a0cfb76a116c6befc5eed7680cc6dee81">00023</a> <span class="comment"></span>        <span class="keyword">protected</span> Dictionary&lt;String, Object&gt; locks = 
<a name="l00024"></a>00024                         <span class="keyword">new</span> Dictionary&lt;string, object&gt;(StringComparer.Ordinal);<span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00026"></a>00026 <span class="comment">        /// Synchronization object for modifications to the &#39;locks&#39; dictionary</span>
<a name="l00027"></a>00027 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00028"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html#af682de769d94aff88a726f3142b5b1ee">00028</a> <span class="comment"></span>        <span class="keyword">protected</span> <span class="keywordtype">object</span> createLock = <span class="keyword">new</span> object();<span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">        /// &lt;summary&gt;</span>
<a name="l00030"></a>00030 <span class="comment">        /// Attempts to execute the &#39;success&#39; callback inside a lock based on &#39;key&#39;.  If successful, returns true.</span>
<a name="l00031"></a>00031 <span class="comment">        /// If the lock cannot be acquired within &#39;timoutMs&#39;, returns false</span>
<a name="l00032"></a>00032 <span class="comment">        /// In a worst-case scenario, it could take up to twice as long as &#39;timeoutMs&#39; to return false.</span>
<a name="l00033"></a>00033 <span class="comment">        /// &lt;/summary&gt;</span>
<a name="l00034"></a>00034 <span class="comment">        /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;</span>
<a name="l00035"></a>00035 <span class="comment">        /// &lt;param name=&quot;success&quot;&gt;&lt;/param&gt;</span>
<a name="l00036"></a>00036 <span class="comment">        /// &lt;param name=&quot;failure&quot;&gt;&lt;/param&gt;</span>
<a name="l00037"></a>00037 <span class="comment">        /// &lt;param name=&quot;timeoutMs&quot;&gt;&lt;/param&gt;</span>
<a name="l00038"></a><a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html#aba5ee5d1323568b30fc351151524ac0c">00038</a> <span class="comment"></span>        <span class="keyword">public</span> <span class="keywordtype">bool</span> <a class="code" href="class_image_resizer_1_1_plugins_1_1_disk_cache_1_1_lock_provider.html#aba5ee5d1323568b30fc351151524ac0c" title="Attempts to execute the &#39;success&#39; callback inside a lock based on &#39;key&#39;. If successful, returns true. If the lock cannot be acquired within &#39;timoutMs&#39;, returns false In a worst-case scenario, it could take up to twice as long as &#39;timeoutMs&#39; to return false.">TryExecute</a>(<span class="keywordtype">string</span> key, <span class="keywordtype">int</span> timeoutMs, LockCallback success){
<a name="l00039"></a>00039             <span class="comment">//Record when we started. We don&#39;t want an infinite loop.</span>
<a name="l00040"></a>00040             DateTime startedAt = DateTime.UtcNow;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042             <span class="comment">// Tracks whether the lock acquired is still correct</span>
<a name="l00043"></a>00043             <span class="keywordtype">bool</span> validLock = <span class="keyword">true</span>; 
<a name="l00044"></a>00044             <span class="comment">// The lock corresponding to &#39;key&#39;</span>
<a name="l00045"></a>00045             <span class="keywordtype">object</span> itemLock = null;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047             <span class="keywordflow">try</span> {
<a name="l00048"></a>00048                 <span class="comment">//We have to loop until we get a valid lock and it stays valid until we lock it.</span>
<a name="l00049"></a>00049                 <span class="keywordflow">do</span> {
<a name="l00050"></a>00050                     <span class="comment">// 1) Creation/aquire phase</span>
<a name="l00051"></a>00051                     lock (createLock) {
<a name="l00052"></a>00052                         <span class="comment">// We have to lock on dictionary writes, since otherwise </span>
<a name="l00053"></a>00053                         <span class="comment">// two locks for the same file could be created and assigned</span>
<a name="l00054"></a>00054                         <span class="comment">// at the same time. (i.e, between TryGetValue and the assignment)</span>
<a name="l00055"></a>00055                         <span class="keywordflow">if</span> (!locks.TryGetValue(key, out itemLock))
<a name="l00056"></a>00056                             locks[key] = itemLock = <span class="keyword">new</span> Object(); <span class="comment">//make a new lock!</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058                     }
<a name="l00059"></a>00059                     <span class="comment">// Loophole (part 1):</span>
<a name="l00060"></a>00060                     <span class="comment">// Right here - this is where another thread (executing part 2) could remove &#39;itemLock&#39;</span>
<a name="l00061"></a>00061                     <span class="comment">// from the dictionary, and potentially, yet another thread could </span>
<a name="l00062"></a>00062                     <span class="comment">// insert a new value for &#39;itemLock&#39; into the dictionary... etc, etc..</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064                     <span class="comment">// 2) Execute phase</span>
<a name="l00065"></a>00065                     <span class="keywordflow">if</span> (System.Threading.Monitor.TryEnter(itemLock, timeoutMs)) {
<a name="l00066"></a>00066                         <span class="keywordflow">try</span> {
<a name="l00067"></a>00067                             <span class="comment">// May take minutes to acquire this lock. </span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069                             <span class="comment">// Trying to detect an occurence of loophole above</span>
<a name="l00070"></a>00070                             <span class="comment">// Check that itemLock still exists and matches the dictionary</span>
<a name="l00071"></a>00071                             lock (createLock) {
<a name="l00072"></a>00072                                 <span class="keywordtype">object</span> newLock = null;
<a name="l00073"></a>00073                                 validLock = locks.TryGetValue(key, out newLock);
<a name="l00074"></a>00074                                 validLock = validLock &amp;&amp; newLock == itemLock;
<a name="l00075"></a>00075                             }
<a name="l00076"></a>00076                             <span class="comment">// Only run the callback if the lock is valid</span>
<a name="l00077"></a>00077                             <span class="keywordflow">if</span> (validLock) {
<a name="l00078"></a>00078                                 success(); <span class="comment">// Extremely long-running callback, perhaps throwing exceptions</span>
<a name="l00079"></a>00079                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00080"></a>00080                             }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082                         } <span class="keywordflow">finally</span> {
<a name="l00083"></a>00083                             System.Threading.Monitor.Exit(itemLock);<span class="comment">//release lock</span>
<a name="l00084"></a>00084                         }
<a name="l00085"></a>00085                     } <span class="keywordflow">else</span> {
<a name="l00086"></a>00086                         validLock = <span class="keyword">false</span>; <span class="comment">//So the finally clause doesn&#39;t try to clean up the lock, someone else will do that.</span>
<a name="l00087"></a>00087                         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">//Someone else had the lock, they can clean it up.</span>
<a name="l00088"></a>00088                     }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090                     <span class="comment">//Are we out of time, still having an invalid lock?</span>
<a name="l00091"></a>00091                     <span class="keywordflow">if</span> (!validLock &amp;&amp; Math.Abs(DateTime.UtcNow.Subtract(startedAt).TotalMilliseconds) &gt; timeoutMs) {
<a name="l00092"></a>00092                         <span class="comment">//We failed to get a valid lock in time. </span>
<a name="l00093"></a>00093                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00094"></a>00094                     }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097                     <span class="comment">// If we had an invalid lock, we have to try everything over again.</span>
<a name="l00098"></a>00098                 } <span class="keywordflow">while</span> (!validLock);
<a name="l00099"></a>00099             } <span class="keywordflow">finally</span> {
<a name="l00100"></a>00100                 <span class="keywordflow">if</span> (validLock) {
<a name="l00101"></a>00101                     <span class="comment">// Loophole (part 2). When loophole part 1 and 2 cross paths,</span>
<a name="l00102"></a>00102                     <span class="comment">// An lock object may be removed before being used, and be orphaned</span>
<a name="l00103"></a>00103 
<a name="l00104"></a>00104                     <span class="comment">// 3) Cleanup phase - Attempt cleanup of lock objects so we don&#39;t </span>
<a name="l00105"></a>00105                     <span class="comment">//   have a *very* large and slow dictionary.</span>
<a name="l00106"></a>00106                     lock (createLock) {
<a name="l00107"></a>00107                         <span class="comment">//  TryEnter() fails instead of waiting. </span>
<a name="l00108"></a>00108                         <span class="comment">//  A normal lock would cause a deadlock with phase 2. </span>
<a name="l00109"></a>00109                         <span class="comment">//  Specifying a timeout would add great and pointless overhead.</span>
<a name="l00110"></a>00110                         <span class="comment">//  Whoever has the lock will clean it up also.</span>
<a name="l00111"></a>00111                         <span class="keywordflow">if</span> (System.Threading.Monitor.TryEnter(itemLock)) {
<a name="l00112"></a>00112                             <span class="keywordflow">try</span> {
<a name="l00113"></a>00113                                 <span class="comment">// It succeeds, so no-one else is working on it </span>
<a name="l00114"></a>00114                                 <span class="comment">// (but may be preparing to, see loophole)</span>
<a name="l00115"></a>00115                                 <span class="comment">// Only remove the lock object if it </span>
<a name="l00116"></a>00116                                 <span class="comment">// still exists in the dictionary as-is</span>
<a name="l00117"></a>00117                                 <span class="keywordtype">object</span> existingLock = null;
<a name="l00118"></a>00118                                 <span class="keywordflow">if</span> (locks.TryGetValue(key, out existingLock)
<a name="l00119"></a>00119                                     &amp;&amp; existingLock == itemLock)
<a name="l00120"></a>00120                                     locks.Remove(key);
<a name="l00121"></a>00121                             } <span class="keywordflow">finally</span> {
<a name="l00122"></a>00122                                 <span class="comment">// Remove the lock</span>
<a name="l00123"></a>00123                                 System.Threading.Monitor.Exit(itemLock);
<a name="l00124"></a>00124                             }
<a name="l00125"></a>00125                         }
<a name="l00126"></a>00126                     }
<a name="l00127"></a>00127                 }
<a name="l00128"></a>00128             }
<a name="l00129"></a>00129             <span class="comment">// Ideally the only objects in &#39;locks&#39; will be open operations now.</span>
<a name="l00130"></a>00130             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00131"></a>00131         }
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
